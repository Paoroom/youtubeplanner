<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mix Visualizer 3D</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #08080d;
    --surface: #101018;
    --surface2: #16161f;
    --surface3: #1c1c2a;
    --border: #252535;
    --text: #e8e8f0;
    --text-dim: #777799;
    --accent: #00d9ce;
    --accent2: #e91e8c;
    --accent3: #7c5cfc;
    --green: #34d399;
    --yellow: #fbbf24;
    --red: #f87171;
  }

  body {
    font-family: 'Inter', -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    user-select: none;
  }

  /* --- Layout --- */
  #app {
    display: grid;
    grid-template-rows: 48px 1fr;
    grid-template-columns: 300px 1fr;
    height: 100vh;
  }

  /* --- Top Bar --- */
  #topbar {
    grid-column: 1 / -1;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 20px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    z-index: 100;
  }
  #topbar .logo {
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 700;
    font-size: 14px;
    letter-spacing: -0.02em;
  }
  #topbar .logo svg { width: 24px; height: 24px; }
  #topbar .actions { display: flex; align-items: center; gap: 8px; }

  .btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 14px;
    border-radius: 6px;
    border: 1px solid var(--border);
    background: var(--surface2);
    color: var(--text);
    font-family: inherit;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all .15s;
    white-space: nowrap;
  }
  .btn:hover { background: var(--surface3); border-color: #3a3a50; }
  .btn.primary {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
    font-weight: 600;
  }
  .btn.primary:hover { filter: brightness(1.15); }
  .btn svg { width: 13px; height: 13px; flex-shrink: 0; }

  /* --- Sidebar --- */
  #sidebar {
    background: var(--surface);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    padding: 14px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
  }
  #sidebar::-webkit-scrollbar { width: 4px; }
  #sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

  .panel {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
  }
  .panel h3 {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-dim);
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .panel h3 .badge {
    font-size: 9px;
    background: var(--surface3);
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: 600;
    letter-spacing: 0;
    color: var(--accent);
  }

  /* Upload area */
  #dropzone {
    border: 2px dashed var(--border);
    border-radius: 10px;
    padding: 24px 12px;
    text-align: center;
    cursor: pointer;
    transition: all .2s;
  }
  #dropzone:hover, #dropzone.dragover {
    border-color: var(--accent);
    background: rgba(0,217,206,0.04);
  }
  #dropzone svg { margin-bottom: 6px; opacity: 0.4; }
  #dropzone p { font-size: 12px; color: var(--text-dim); margin-top: 4px; }
  #dropzone .filename {
    font-size: 11px;
    color: var(--accent);
    margin-top: 6px;
    word-break: break-all;
  }
  #fileInput { display: none; }

  /* Instrument list */
  .instrument-list { display: flex; flex-direction: column; gap: 3px; }
  .instrument-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    border-radius: 6px;
    background: rgba(255,255,255,0.02);
    font-size: 12px;
    transition: all .15s;
    cursor: pointer;
  }
  .instrument-item:hover { background: rgba(255,255,255,0.05); }
  .instrument-item.hidden-el { opacity: 0.3; }
  .instrument-item.hidden-el .instrument-name { text-decoration: line-through; }

  /* Eye toggle */
  .eye-toggle {
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity .15s;
    flex-shrink: 0;
  }
  .eye-toggle:hover { opacity: 1; }
  .eye-toggle svg { width: 14px; height: 14px; }

  .instrument-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .instrument-name { flex: 1; font-weight: 500; font-size: 11px; }

  /* Volume bar */
  .vol-bar-wrap {
    width: 48px;
    height: 6px;
    background: var(--surface);
    border-radius: 3px;
    overflow: hidden;
    flex-shrink: 0;
  }
  .vol-bar {
    height: 100%;
    border-radius: 3px;
    transition: width .3s;
  }
  .instrument-db {
    font-size: 9px;
    color: var(--text-dim);
    width: 38px;
    text-align: right;
    font-variant-numeric: tabular-nums;
    flex-shrink: 0;
  }
  .instrument-pan-badge {
    font-size: 9px;
    color: var(--text-dim);
    background: var(--surface);
    padding: 1px 5px;
    border-radius: 3px;
    font-weight: 600;
    flex-shrink: 0;
    min-width: 22px;
    text-align: center;
  }

  /* Sliders */
  .slider-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  .slider-row:last-child { margin-bottom: 0; }
  .slider-row label {
    font-size: 11px;
    color: var(--text-dim);
    width: 70px;
    flex-shrink: 0;
  }
  .slider-row input[type=range] {
    flex: 1;
    -webkit-appearance: none;
    height: 3px;
    border-radius: 2px;
    background: var(--border);
    outline: none;
  }
  .slider-row input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: 2px solid var(--surface);
  }

  /* Analyzing state */
  .analyzing-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(8,8,13,0.9);
    z-index: 200;
    gap: 16px;
  }
  .analyzing-overlay .spinner {
    width: 36px;
    height: 36px;
    border: 3px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.7s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .analyzing-overlay p { font-size: 13px; color: var(--text-dim); }

  /* --- 3D Canvas area --- */
  #canvas-wrap {
    position: relative;
    overflow: hidden;
    background: var(--bg);
  }
  #canvas-wrap canvas { display: block; }

  /* Controls help */
  .controls-help {
    position: absolute;
    top: 12px;
    right: 12px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    font-size: 10px;
    color: var(--text-dim);
    background: rgba(16,16,24,0.85);
    backdrop-filter: blur(8px);
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid var(--border);
    pointer-events: none;
    opacity: 0.7;
    line-height: 1.5;
    z-index: 10;
  }
  .controls-help kbd {
    display: inline-block;
    background: var(--surface3);
    border: 1px solid var(--border);
    border-radius: 3px;
    padding: 0 4px;
    font-family: inherit;
    font-size: 9px;
    color: var(--text);
  }

  /* HUD overlay */
  .hud-bottom {
    position: absolute;
    bottom: 14px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 24px;
    background: rgba(16,16,24,0.85);
    backdrop-filter: blur(12px);
    padding: 6px 18px;
    border-radius: 16px;
    border: 1px solid var(--border);
    pointer-events: none;
    font-size: 10px;
    color: var(--text-dim);
    z-index: 10;
  }
  .hud-axis { display: flex; align-items: center; gap: 5px; }
  .hud-axis .arrow { color: var(--accent); font-size: 12px; }

  /* Tooltip */
  #tooltip {
    position: absolute;
    display: none;
    pointer-events: none;
    background: rgba(16,16,24,0.95);
    backdrop-filter: blur(12px);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 14px;
    font-size: 11px;
    z-index: 50;
    min-width: 160px;
  }
  #tooltip .tt-name { font-weight: 700; font-size: 13px; margin-bottom: 6px; }
  #tooltip .tt-row { display: flex; justify-content: space-between; gap: 16px; color: var(--text-dim); margin-top: 3px; }
  #tooltip .tt-val { color: var(--text); font-weight: 600; font-variant-numeric: tabular-nums; }
  #tooltip .tt-volbar {
    width: 100%;
    height: 5px;
    background: var(--surface3);
    border-radius: 3px;
    margin-top: 6px;
    overflow: hidden;
  }
  #tooltip .tt-volbar-fill {
    height: 100%;
    border-radius: 3px;
  }

  /* Transport */
  .transport {
    position: absolute;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 6px;
    z-index: 30;
  }
  .transport button {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: 1px solid var(--border);
    background: rgba(16,16,24,0.9);
    color: var(--text);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all .15s;
    backdrop-filter: blur(8px);
  }
  .transport button:hover { border-color: var(--accent); color: var(--accent); }
  .transport button.active { background: var(--accent); color: #000; border-color: var(--accent); }
  .transport button svg { width: 14px; height: 14px; }

  /* Empty state */
  .empty-state {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    color: var(--text-dim);
  }
  .empty-state svg { opacity: 0.2; }
  .empty-state p { font-size: 13px; }

  /* Progress bar */
  .progress-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 2px;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    transition: width 0.1s linear;
    z-index: 10;
  }

  /* Freq zone legend on canvas */
  .freq-legend {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 0;
    pointer-events: none;
    z-index: 5;
  }
  .freq-zone {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 3px 8px;
    font-size: 9px;
    font-weight: 600;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    border-left: 3px solid;
    background: rgba(8,8,13,0.6);
  }

  /* Depth legend */
  .depth-legend {
    position: absolute;
    bottom: 50px;
    right: 12px;
    pointer-events: none;
    z-index: 5;
    display: flex;
    flex-direction: column;
    gap: 2px;
    font-size: 9px;
    color: var(--text-dim);
    background: rgba(16,16,24,0.8);
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid var(--border);
  }
  .depth-legend .depth-bar {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .depth-legend .depth-sample {
    width: 20px;
    height: 4px;
    border-radius: 2px;
  }

  @media (max-width: 900px) {
    #app { grid-template-columns: 1fr; }
    #sidebar { display: none; }
  }
</style>
</head>
<body>
<div id="app">
  <!-- Top Bar -->
  <div id="topbar">
    <div class="logo">
      <svg viewBox="0 0 28 28" fill="none">
        <circle cx="14" cy="14" r="13" stroke="currentColor" stroke-width="1.5" opacity="0.3"/>
        <circle cx="14" cy="14" r="6" fill="url(#g1)"/>
        <circle cx="14" cy="8" r="2.5" fill="url(#g2)"/>
        <circle cx="9" cy="18" r="3.5" fill="url(#g3)" opacity="0.7"/>
        <circle cx="19" cy="17" r="2" fill="url(#g4)" opacity="0.6"/>
        <defs>
          <radialGradient id="g1"><stop stop-color="#7c5cfc"/><stop offset="1" stop-color="#5c3cdc"/></radialGradient>
          <radialGradient id="g2"><stop stop-color="#e91e8c"/><stop offset="1" stop-color="#c9006c"/></radialGradient>
          <radialGradient id="g3"><stop stop-color="#00d9ce"/><stop offset="1" stop-color="#00a99e"/></radialGradient>
          <radialGradient id="g4"><stop stop-color="#ffd600"/><stop offset="1" stop-color="#ffaa00"/></radialGradient>
        </defs>
      </svg>
      Mix Visualizer 3D
    </div>
    <div class="actions">
      <button class="btn" id="btnShowAll" title="Tout afficher">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
        Tout afficher
      </button>
      <a href="trackmap.html" class="btn" style="text-decoration:none;">TrackMap</a>
      <button class="btn" id="btnReset" title="Reset">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 4v6h6M23 20v-6h-6"/><path d="M20.49 9A9 9 0 005.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 013.51 15"/></svg>
        Reset
      </button>
    </div>
  </div>

  <!-- Sidebar -->
  <div id="sidebar">
    <!-- Upload -->
    <div id="dropzone" tabindex="0">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
        <polyline points="17 8 12 3 7 8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
      </svg>
      <p>Glisser un fichier audio ici<br>ou <strong style="color:var(--accent)">cliquer pour parcourir</strong></p>
      <p style="font-size:10px;margin-top:3px;opacity:0.4">WAV, MP3, FLAC, OGG</p>
      <div class="filename" id="fileName"></div>
    </div>
    <input type="file" id="fileInput" accept="audio/*">

    <!-- Detected Instruments -->
    <div class="panel" id="panelInstruments" style="display:none">
      <h3>Elements du mix <span class="badge" id="elCount">0</span></h3>
      <div class="instrument-list" id="instrumentList"></div>
    </div>

    <!-- Camera Controls -->
    <div class="panel">
      <h3>Camera</h3>
      <div class="slider-row">
        <label>Zoom</label>
        <input type="range" id="sliderZoom" min="5" max="60" value="22">
      </div>
      <div class="slider-row">
        <label>Elevation</label>
        <input type="range" id="sliderElevation" min="-10" max="80" value="20">
      </div>
      <div class="slider-row">
        <label>Angle</label>
        <input type="range" id="sliderAngle" min="-180" max="180" value="0">
      </div>
    </div>

    <!-- Analysis Settings -->
    <div class="panel">
      <h3>Analyse</h3>
      <div class="slider-row">
        <label>Sensibilite</label>
        <input type="range" id="sliderSensitivity" min="1" max="100" value="50">
      </div>
      <div class="slider-row">
        <label>Smoothing</label>
        <input type="range" id="sliderSmoothing" min="0" max="100" value="70">
      </div>
    </div>

    <!-- Legend -->
    <div class="panel">
      <h3>Axes</h3>
      <div style="font-size:11px;color:var(--text-dim);line-height:2">
        <div><span style="color:var(--accent)">&#9654;</span> <strong style="color:var(--text)">Gauche ↔ Droite</strong> — Panoramique stereo</div>
        <div><span style="color:var(--accent2)">&#9650;</span> <strong style="color:var(--text)">Bas ↔ Haut</strong> — Frequence (grave → aigu)</div>
        <div><span style="color:var(--accent3)">&#9679;</span> <strong style="color:var(--text)">Taille sphere</strong> — Volume relatif (dB)</div>
        <div><span style="color:#fbbf24">&#9670;</span> <strong style="color:var(--text)">Avant ↔ Arriere</strong> — Profondeur / reverb</div>
      </div>
    </div>
  </div>

  <!-- 3D Canvas Area -->
  <div id="canvas-wrap">
    <div class="empty-state" id="emptyState">
      <svg width="56" height="56" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
        <circle cx="12" cy="12" r="10"/>
        <path d="M12 8v4l3 3"/>
      </svg>
      <p>Importer un fichier audio pour commencer l'analyse</p>
    </div>

    <canvas id="scene"></canvas>

    <div id="tooltip">
      <div class="tt-name"></div>
      <div class="tt-row"><span>Volume</span><span class="tt-val" id="ttVol"></span></div>
      <div class="tt-volbar"><div class="tt-volbar-fill" id="ttVolBar"></div></div>
      <div class="tt-row"><span>Pan</span><span class="tt-val" id="ttPan"></span></div>
      <div class="tt-row"><span>Frequences</span><span class="tt-val" id="ttFreq"></span></div>
      <div class="tt-row"><span>Profondeur</span><span class="tt-val" id="ttDepth"></span></div>
    </div>

    <!-- Controls help -->
    <div class="controls-help" id="controlsHelp" style="display:none">
      <div><kbd>Clic gauche</kbd> + glisser → Orbite</div>
      <div><kbd>Clic droit</kbd> + glisser → Deplacement</div>
      <div><kbd>Molette</kbd> → Zoom</div>
      <div><kbd>Double-clic</kbd> → Recentrer</div>
    </div>

    <!-- Freq zones (left side) -->
    <div class="freq-legend" id="freqLegend" style="display:none">
      <div class="freq-zone" style="border-color:#f87171;color:#f87171">Air 10k+</div>
      <div class="freq-zone" style="border-color:#fbbf24;color:#fbbf24">Presence 4k-10k</div>
      <div class="freq-zone" style="border-color:#34d399;color:#34d399">Mediums 500-4k</div>
      <div class="freq-zone" style="border-color:#60a5fa;color:#60a5fa">Low-Mid 200-500</div>
      <div class="freq-zone" style="border-color:#a78bfa;color:#a78bfa">Bass 60-200</div>
      <div class="freq-zone" style="border-color:#7c5cfc;color:#7c5cfc">Sub 20-60</div>
    </div>

    <!-- Depth legend -->
    <div class="depth-legend" id="depthLegend" style="display:none">
      <div style="font-weight:600;margin-bottom:3px;color:var(--text)">Profondeur</div>
      <div class="depth-bar"><div class="depth-sample" style="background:var(--text);opacity:1"></div> Devant (dry)</div>
      <div class="depth-bar"><div class="depth-sample" style="background:var(--text);opacity:0.5"></div> Milieu</div>
      <div class="depth-bar"><div class="depth-sample" style="background:var(--text);opacity:0.2"></div> Arriere (wet)</div>
    </div>

    <!-- HUD -->
    <div class="hud-bottom" id="hudBottom" style="display:none">
      <div class="hud-axis"><span class="arrow">←</span> L — Stereo — R <span class="arrow">→</span></div>
      <div class="hud-axis"><span class="arrow">↓</span> Grave — Aigu <span class="arrow">↑</span></div>
      <div class="hud-axis">Taille = Volume</div>
    </div>

    <!-- Transport -->
    <div class="transport" id="transport" style="display:none">
      <button id="btnPlay" title="Lecture">
        <svg viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg>
      </button>
      <button id="btnPause" title="Pause">
        <svg viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
      </button>
      <button id="btnLive" title="Mode temps reel">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z"/><circle cx="12" cy="12" r="3"/></svg>
      </button>
    </div>

    <div class="progress-bar" id="progressBar" style="width:0%"></div>
  </div>
</div>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
//  MIX VISUALIZER 3D v2 — Full Camera Controls, Visibility,
//  Clear Volume/Freq/Depth
// ============================================================
(function() {
'use strict';

// ----- Constants -----
const INSTRUMENT_DEFS = [
  { id: 'sub',    name: 'Sub Bass',       color: '#7c5cfc', freqRange: [20, 60],     yPos: 0.02, depthHint: 0.3 },
  { id: 'kick',   name: 'Kick',           color: '#d4a053', freqRange: [40, 120],    yPos: 0.08, depthHint: 0.15 },
  { id: 'bass',   name: 'Bass',           color: '#00c9a7', freqRange: [60, 250],    yPos: 0.16, depthHint: 0.2 },
  { id: 'snare',  name: 'Snare',          color: '#e63946', freqRange: [150, 1000],  yPos: 0.35, depthHint: 0.25 },
  { id: 'keys',   name: 'Keys / Piano',   color: '#f4a261', freqRange: [200, 2000],  yPos: 0.45, depthHint: 0.45 },
  { id: 'vocal',  name: 'Lead Vocal',     color: '#a78bfa', freqRange: [250, 4000],  yPos: 0.55, depthHint: 0.1 },
  { id: 'guitar', name: 'Guitare',        color: '#2a9d8f', freqRange: [200, 5000],  yPos: 0.48, depthHint: 0.4 },
  { id: 'clap',   name: 'Clap / Perc',    color: '#ffd166', freqRange: [500, 4000],  yPos: 0.52, depthHint: 0.3 },
  { id: 'bgv',    name: 'BGV / Choeurs',  color: '#e91e8c', freqRange: [300, 5000],  yPos: 0.58, depthHint: 0.6 },
  { id: 'synth',  name: 'Synth / Pad',    color: '#4cc9f0', freqRange: [150, 8000],  yPos: 0.50, depthHint: 0.55 },
  { id: 'hihat',  name: 'Hi-Hats',        color: '#b5e48c', freqRange: [5000,16000], yPos: 0.82, depthHint: 0.2 },
  { id: 'cymbal', name: 'Cymbales',       color: '#d0d0d0', freqRange: [4000,18000], yPos: 0.88, depthHint: 0.35 },
  { id: 'air',    name: 'Air / Brillance', color:'#f0f0ff',  freqRange:[10000,20000], yPos: 0.95, depthHint: 0.7 },
];

// Freq zone colors for grid bands
const FREQ_ZONES = [
  { label: 'Sub',       range: [20,60],     color: '#7c5cfc', yStart: 0, yEnd: 0.05 },
  { label: 'Bass',      range: [60,200],    color: '#a78bfa', yStart: 0.05, yEnd: 0.18 },
  { label: 'Low-Mid',   range: [200,500],   color: '#60a5fa', yStart: 0.18, yEnd: 0.38 },
  { label: 'Mediums',   range: [500,4000],  color: '#34d399', yStart: 0.38, yEnd: 0.70 },
  { label: 'Presence',  range: [4000,10000],color: '#fbbf24', yStart: 0.70, yEnd: 0.85 },
  { label: 'Air',       range:[10000,20000],color: '#f87171', yStart: 0.85, yEnd: 1.0 },
];

const SCENE_HEIGHT = 14; // total Y units
const SCENE_WIDTH = 12;  // X half-range for pan
const SCENE_DEPTH = 10;  // Z range for depth

// ----- State -----
let audioCtx = null;
let audioBuffer = null;
let sourceNode = null;
let analyserL = null, analyserR = null;
let splitter = null;
let isPlaying = false;
let playStartTime = 0;
let playOffset = 0;
let animationId = null;
let detectedElements = [];
let hiddenIds = new Set(); // hidden element ids
let liveMode = false;

// Three.js
let scene, camera, renderer, clock;
let elementGroups = []; // { group, mesh, glow, label, shadow, stem, ring }
let mouseVec = new THREE.Vector2(-999, -999);
let raycaster = new THREE.Raycaster();
let hoveredMesh = null;

// Camera control state
let camDist = 22;
let camTheta = 0; // horizontal angle (radians)
let camPhi = 20 * Math.PI / 180; // elevation angle
let camTarget = new THREE.Vector3(0, 4, 0);
let camDragging = false;
let camPanning = false;
let camLastX = 0, camLastY = 0;

// Settings
const settings = {
  sensitivity: 50,
  smoothing: 70,
};

// ----- DOM -----
const $ = id => document.getElementById(id);
const canvas = $('scene');
const dropzone = $('dropzone');
const fileInput = $('fileInput');

// ----- Audio Context -----
function getAudioContext() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

// ----- File Loading -----
dropzone.addEventListener('click', () => fileInput.click());
dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', e => {
  e.preventDefault();
  dropzone.classList.remove('dragover');
  if (e.dataTransfer.files.length) loadFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', e => {
  if (e.target.files.length) loadFile(e.target.files[0]);
});

async function loadFile(file) {
  $('fileName').textContent = file.name;
  const ctx = getAudioContext();
  showAnalyzing(true);

  try {
    const arrayBuffer = await file.arrayBuffer();
    audioBuffer = await ctx.decodeAudioData(arrayBuffer);
    hiddenIds.clear();
    analyzeFullAudio();
    $('emptyState').style.display = 'none';
    $('hudBottom').style.display = 'flex';
    $('transport').style.display = 'flex';
    $('panelInstruments').style.display = 'block';
    $('controlsHelp').style.display = 'block';
    $('freqLegend').style.display = 'flex';
    $('depthLegend').style.display = 'flex';
    initThreeScene();
    buildElementMeshes();
    startVisualization();
  } catch(err) {
    console.error('Error loading audio:', err);
    alert('Erreur lors du chargement du fichier audio.');
  }
  showAnalyzing(false);
}

function showAnalyzing(show) {
  let el = document.querySelector('.analyzing-overlay');
  if (show && !el) {
    el = document.createElement('div');
    el.className = 'analyzing-overlay';
    el.innerHTML = '<div class="spinner"></div><p>Analyse en cours...</p>';
    $('canvas-wrap').appendChild(el);
  } else if (!show && el) {
    el.remove();
  }
}

// ======================================================
//  AUDIO ANALYSIS
// ======================================================
function analyzeFullAudio() {
  if (!audioBuffer) return;

  const sampleRate = audioBuffer.sampleRate;
  const fftSize = 8192;
  const numChannels = audioBuffer.numberOfChannels;
  const dataL = audioBuffer.getChannelData(0);
  const dataR = numChannels > 1 ? audioBuffer.getChannelData(1) : dataL;
  const length = dataL.length;
  const freqBinCount = fftSize / 2;

  // Hann window
  const win = new Float32Array(fftSize);
  for (let i = 0; i < fftSize; i++) {
    win[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));
  }

  const hopSize = fftSize;
  const numWindows = Math.min(Math.floor(length / hopSize), 120);

  detectedElements = [];

  // Init accumulators per instrument
  const accum = INSTRUMENT_DEFS.map(def => ({
    ...def,
    sumL: 0, sumR: 0, count: 0,
    lowBin: Math.max(1, Math.floor(def.freqRange[0] * fftSize / sampleRate)),
    highBin: Math.min(freqBinCount - 1, Math.floor(def.freqRange[1] * fftSize / sampleRate)),
  }));

  for (let w = 0; w < numWindows; w++) {
    const offset = w * hopSize;
    const realL = new Float32Array(fftSize);
    const realR = new Float32Array(fftSize);

    for (let i = 0; i < fftSize && offset + i < length; i++) {
      realL[i] = dataL[offset + i] * win[i];
      realR[i] = dataR[offset + i] * win[i];
    }

    for (const a of accum) {
      const step = Math.max(1, Math.floor((a.highBin - a.lowBin) / 24));
      let sL = 0, sR = 0, bc = 0;

      for (let k = a.lowBin; k <= a.highBin; k += step) {
        // Goertzel
        const freq = 2 * Math.PI * k / fftSize;
        const coeff = 2 * Math.cos(freq);
        let s1L = 0, s2L = 0, s1R = 0, s2R = 0;

        for (let n = 0; n < fftSize; n++) {
          let s0L = realL[n] + coeff * s1L - s2L;
          s2L = s1L; s1L = s0L;
          let s0R = realR[n] + coeff * s1R - s2R;
          s2R = s1R; s1R = s0R;
        }

        sL += Math.sqrt(s1L*s1L + s2L*s2L - coeff*s1L*s2L);
        sR += Math.sqrt(s1R*s1R + s2R*s2R - coeff*s1R*s2R);
        bc++;
      }

      a.sumL += sL / (bc || 1);
      a.sumR += sR / (bc || 1);
      a.count++;
    }
  }

  // Compute results
  for (const a of accum) {
    if (a.count > 0) {
      a.sumL /= a.count;
      a.sumR /= a.count;
    }
    const total = a.sumL + a.sumR;
    const energy = total / 2;
    const pan = total > 0 ? (a.sumR - a.sumL) / total : 0;

    const threshold = 0.5 * (settings.sensitivity / 50);
    if (energy > threshold) {
      detectedElements.push({
        id: a.id,
        name: a.name,
        color: a.color,
        freqRange: a.freqRange,
        yPos: a.yPos,
        depthHint: a.depthHint,
        energy,
        pan: Math.max(-1, Math.min(1, pan)),
        volumeDb: 20 * Math.log10(energy + 1e-10),
      });
    }
  }

  // Normalize
  if (detectedElements.length > 0) {
    const maxE = Math.max(...detectedElements.map(e => e.energy));
    const minDb = Math.min(...detectedElements.map(e => e.volumeDb));
    const maxDb = Math.max(...detectedElements.map(e => e.volumeDb));
    detectedElements.forEach(e => {
      e.normalizedVol = Math.pow(e.energy / (maxE || 1), 0.4);
      e.dbDisplay = e.volumeDb.toFixed(1);
      // Normalize dB to 0-1 for display
      e.dbNorm = maxDb > minDb ? (e.volumeDb - minDb) / (maxDb - minDb) : 0.5;
    });
  }

  updateInstrumentList();
}

// ======================================================
//  SIDEBAR INSTRUMENT LIST (with visibility toggle)
// ======================================================
function updateInstrumentList() {
  const list = $('instrumentList');
  list.innerHTML = '';

  detectedElements.sort((a, b) => b.energy - a.energy);
  $('elCount').textContent = detectedElements.length;

  detectedElements.forEach(el => {
    const div = document.createElement('div');
    div.className = 'instrument-item' + (hiddenIds.has(el.id) ? ' hidden-el' : '');
    div.dataset.id = el.id;

    const volPct = Math.round((el.normalizedVol || 0) * 100);
    const panLabel = el.pan < -0.1 ? `L${Math.round(Math.abs(el.pan)*100)}` :
                     el.pan > 0.1 ? `R${Math.round(el.pan*100)}` : 'C';

    // Volume bar color gradient based on level
    const barColor = volPct > 80 ? 'var(--red)' : volPct > 50 ? 'var(--yellow)' : 'var(--green)';

    div.innerHTML = `
      <span class="eye-toggle" data-id="${el.id}" title="Masquer/afficher">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          ${hiddenIds.has(el.id)
            ? '<line x1="1" y1="1" x2="23" y2="23"/><path d="M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94"/><path d="M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19"/>'
            : '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>'
          }
        </svg>
      </span>
      <span class="instrument-dot" style="background:${el.color}"></span>
      <span class="instrument-name">${el.name}</span>
      <span class="vol-bar-wrap"><span class="vol-bar" style="width:${volPct}%;background:${barColor}"></span></span>
      <span class="instrument-db">${el.dbDisplay} dB</span>
      <span class="instrument-pan-badge">${panLabel}</span>
    `;

    list.appendChild(div);
  });

  // Attach toggle listeners
  list.querySelectorAll('.eye-toggle').forEach(btn => {
    btn.addEventListener('click', e => {
      e.stopPropagation();
      const id = btn.dataset.id;
      if (hiddenIds.has(id)) hiddenIds.delete(id);
      else hiddenIds.add(id);
      updateInstrumentList();
      updateMeshVisibility();
    });
  });
}

function updateMeshVisibility() {
  elementGroups.forEach(g => {
    const visible = !hiddenIds.has(g.elId);
    g.group.visible = visible;
  });
}

// ======================================================
//  THREE.JS SCENE
// ======================================================
function initThreeScene() {
  if (renderer) {
    // Clear old element groups only, rebuild
    elementGroups.forEach(g => scene.remove(g.group));
    elementGroups = [];
    return;
  }

  const wrap = $('canvas-wrap');
  const w = wrap.clientWidth;
  const h = wrap.clientHeight;

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x08080d, 0.008);

  camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 500);
  updateCamera();

  renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
  renderer.setSize(w, h);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x08080d);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;

  clock = new THREE.Clock();

  // Lights
  scene.add(new THREE.AmbientLight(0x404060, 0.5));

  const dir = new THREE.DirectionalLight(0xffffff, 0.7);
  dir.position.set(8, 20, 10);
  scene.add(dir);

  const p1 = new THREE.PointLight(0x00d9ce, 0.5, 60);
  p1.position.set(-12, 10, 5);
  scene.add(p1);

  const p2 = new THREE.PointLight(0xe91e8c, 0.3, 60);
  p2.position.set(12, 5, -5);
  scene.add(p2);

  // Stage floor
  createStage();
  createGrid();

  // Events
  window.addEventListener('resize', onResize);
  setupCameraControls();
}

function createStage() {
  // Floor
  const fg = new THREE.PlaneGeometry(SCENE_WIDTH * 2 + 8, SCENE_DEPTH + 8);
  const fm = new THREE.MeshPhysicalMaterial({
    color: 0x08080e, metalness: 0.9, roughness: 0.25,
    transparent: true, opacity: 0.5,
  });
  const floor = new THREE.Mesh(fg, fm);
  floor.rotation.x = -Math.PI / 2;
  floor.position.set(0, -0.05, 0);
  scene.add(floor);

  // Floor border glow
  const eg = new THREE.EdgesGeometry(new THREE.PlaneGeometry(SCENE_WIDTH * 2 + 4, SCENE_DEPTH + 4));
  const em = new THREE.LineBasicMaterial({ color: 0x00d9ce, transparent: true, opacity: 0.12 });
  const el = new THREE.LineSegments(eg, em);
  el.rotation.x = -Math.PI / 2;
  scene.add(el);
}

function createGrid() {
  const gridColor = 0x151520;
  const gridMat = new THREE.LineBasicMaterial({ color: gridColor, transparent: true, opacity: 0.5 });

  // Back wall - frequency zone colored bands
  FREQ_ZONES.forEach(zone => {
    const y0 = zone.yStart * SCENE_HEIGHT;
    const y1 = zone.yEnd * SCENE_HEIGHT;
    const planeGeo = new THREE.PlaneGeometry(SCENE_WIDTH * 2 + 4, y1 - y0);
    const planeMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(zone.color),
      transparent: true,
      opacity: 0.03,
      side: THREE.DoubleSide,
    });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.position.set(0, (y0 + y1) / 2, -SCENE_DEPTH / 2 - 1);
    scene.add(plane);

    // Horizontal line at zone boundary
    const lineGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-SCENE_WIDTH - 2, y1, -SCENE_DEPTH / 2 - 1),
      new THREE.Vector3(SCENE_WIDTH + 2, y1, -SCENE_DEPTH / 2 - 1),
    ]);
    const lineMat = new THREE.LineBasicMaterial({
      color: new THREE.Color(zone.color),
      transparent: true,
      opacity: 0.15,
    });
    scene.add(new THREE.Line(lineGeo, lineMat));
  });

  // Vertical pan guides on back wall
  for (let i = -4; i <= 4; i++) {
    const x = i * (SCENE_WIDTH / 4);
    const geo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(x, 0, -SCENE_DEPTH / 2 - 1),
      new THREE.Vector3(x, SCENE_HEIGHT, -SCENE_DEPTH / 2 - 1),
    ]);
    const mat = new THREE.LineBasicMaterial({
      color: i === 0 ? 0x00d9ce : gridColor,
      transparent: true,
      opacity: i === 0 ? 0.25 : 0.3,
    });
    scene.add(new THREE.Line(geo, mat));
  }

  // Floor grid lines (depth guides)
  for (let z = -SCENE_DEPTH / 2; z <= SCENE_DEPTH / 2; z += 2) {
    const geo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(-SCENE_WIDTH - 2, 0, z),
      new THREE.Vector3(SCENE_WIDTH + 2, 0, z),
    ]);
    scene.add(new THREE.Line(geo, gridMat));
  }
  for (let x = -SCENE_WIDTH; x <= SCENE_WIDTH; x += 3) {
    const geo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(x, 0, -SCENE_DEPTH / 2),
      new THREE.Vector3(x, 0, SCENE_DEPTH / 2),
    ]);
    scene.add(new THREE.Line(geo, gridMat));
  }

  // Labels
  addText('L', -SCENE_WIDTH - 0.5, -0.5, -SCENE_DEPTH / 2 - 1, '#00d9ce', 0.4);
  addText('C', 0, -0.5, -SCENE_DEPTH / 2 - 1, '#00d9ce', 0.3);
  addText('R', SCENE_WIDTH + 0.5, -0.5, -SCENE_DEPTH / 2 - 1, '#00d9ce', 0.4);

  // Freq labels on back wall
  FREQ_ZONES.forEach(zone => {
    const y = ((zone.yStart + zone.yEnd) / 2) * SCENE_HEIGHT;
    addText(zone.label, -SCENE_WIDTH - 3, y, -SCENE_DEPTH / 2 - 1, zone.color, 0.22);
  });

  // Depth labels on floor
  addText('DEVANT (Dry)', 0, 0.1, SCENE_DEPTH / 2 + 1.2, '#fbbf24', 0.22);
  addText('ARRIERE (Wet)', 0, 0.1, -SCENE_DEPTH / 2 + 1, '#fbbf24', 0.18);
}

function addText(text, x, y, z, color, scale) {
  const c2 = document.createElement('canvas');
  c2.width = 512;
  c2.height = 64;
  const ctx2 = c2.getContext('2d');
  ctx2.font = 'bold 36px Inter, sans-serif';
  ctx2.fillStyle = color;
  ctx2.textAlign = 'center';
  ctx2.textBaseline = 'middle';
  ctx2.fillText(text, 256, 32);

  const tex = new THREE.CanvasTexture(c2);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.8 });
  const sprite = new THREE.Sprite(mat);
  sprite.position.set(x, y, z);
  sprite.scale.set(scale * 5, scale * 0.7, 1);
  scene.add(sprite);
  return sprite;
}

// ======================================================
//  BUILD ELEMENT MESHES
// ======================================================
function buildElementMeshes() {
  elementGroups.forEach(g => scene.remove(g.group));
  elementGroups = [];

  detectedElements.forEach((el, i) => {
    const group = new THREE.Group();

    // Size based on volume (clear differentiation)
    const minSize = 0.25;
    const maxSize = 2.0;
    const size = minSize + (el.normalizedVol || 0.5) * (maxSize - minSize);

    // Position
    const x = el.pan * SCENE_WIDTH;
    const y = el.yPos * SCENE_HEIGHT;
    const z = (0.5 - el.depthHint) * SCENE_DEPTH; // front=positive, back=negative

    // Main sphere
    const geo = new THREE.SphereGeometry(size, 32, 32);
    const mat = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color(el.color),
      metalness: 0.05,
      roughness: 0.35,
      clearcoat: 0.6,
      clearcoatRoughness: 0.15,
      emissive: new THREE.Color(el.color),
      emissiveIntensity: 0.2,
      transparent: true,
      opacity: 0.9 - el.depthHint * 0.3, // deeper = more transparent
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0, 0, 0);
    group.add(mesh);

    // Glow ring (volume indicator)
    const ringGeo = new THREE.TorusGeometry(size + 0.15, 0.04 + el.normalizedVol * 0.06, 8, 48);
    const ringMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(el.color),
      transparent: true,
      opacity: 0.25,
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2;
    group.add(ring);

    // Outer glow
    const glowGeo = new THREE.SphereGeometry(size * 1.4, 16, 16);
    const glowMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(el.color),
      transparent: true,
      opacity: 0.06,
    });
    const glow = new THREE.Mesh(glowGeo, glowMat);
    group.add(glow);

    // Label above
    const label = addText(el.name, 0, size + 0.5, 0, el.color, 0.20);
    // Remove from scene, add to group instead
    scene.remove(label);
    group.add(label);

    // dB label below
    const dbLabel = addText(el.dbDisplay + ' dB', 0, -(size + 0.4), 0, '#8888aa', 0.15);
    scene.remove(dbLabel);
    group.add(dbLabel);

    // Vertical stem to floor
    const stemGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, -y, 0), // goes down to floor in local space
      new THREE.Vector3(0, 0, 0),
    ]);
    const stemMat = new THREE.LineDashedMaterial({
      color: new THREE.Color(el.color),
      transparent: true,
      opacity: 0.15,
      dashSize: 0.3,
      gapSize: 0.2,
    });
    const stem = new THREE.Line(stemGeo, stemMat);
    stem.computeLineDistances();
    group.add(stem);

    // Shadow circle on floor
    const shadowGeo = new THREE.RingGeometry(size * 0.4, size * 0.7, 24);
    const shadowMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(el.color),
      transparent: true,
      opacity: 0.08,
      side: THREE.DoubleSide,
    });
    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = -y + 0.02;
    group.add(shadow);

    group.position.set(x, y, z);

    scene.add(group);

    elementGroups.push({
      group,
      mesh,
      glow,
      ring,
      label,
      dbLabel,
      stem,
      shadow,
      elId: el.id,
      element: el,
      baseY: y,
      baseSize: size,
      index: i,
    });
  });

  updateMeshVisibility();
}

// ======================================================
//  CAMERA CONTROLS (orbit, pan, zoom — no auto-rotate)
// ======================================================
function setupCameraControls() {
  // Left click = orbit
  canvas.addEventListener('mousedown', e => {
    if (e.button === 0) {
      camDragging = true;
      camLastX = e.clientX;
      camLastY = e.clientY;
    }
    // Right click = pan
    if (e.button === 2) {
      camPanning = true;
      camLastX = e.clientX;
      camLastY = e.clientY;
    }
  });

  window.addEventListener('mousemove', e => {
    if (camDragging) {
      const dx = e.clientX - camLastX;
      const dy = e.clientY - camLastY;
      camTheta -= dx * 0.005;
      camPhi = Math.max(-0.2, Math.min(Math.PI / 2 - 0.05, camPhi + dy * 0.005));
      camLastX = e.clientX;
      camLastY = e.clientY;
      syncSlidersFromCamera();
    }
    if (camPanning) {
      const dx = e.clientX - camLastX;
      const dy = e.clientY - camLastY;
      // Pan in camera-local space
      const right = new THREE.Vector3();
      const up = new THREE.Vector3(0, 1, 0);
      camera.getWorldDirection(right);
      right.cross(up).normalize();
      const panSpeed = camDist * 0.002;
      camTarget.add(right.multiplyScalar(-dx * panSpeed));
      camTarget.y += dy * panSpeed;
      camLastX = e.clientX;
      camLastY = e.clientY;
    }
  });

  window.addEventListener('mouseup', e => {
    if (e.button === 0) camDragging = false;
    if (e.button === 2) camPanning = false;
  });

  canvas.addEventListener('contextmenu', e => e.preventDefault());

  // Wheel = zoom
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    camDist *= e.deltaY > 0 ? 1.08 : 0.92;
    camDist = Math.max(5, Math.min(60, camDist));
    syncSlidersFromCamera();
  }, { passive: false });

  // Double-click = reset view
  canvas.addEventListener('dblclick', () => {
    camDist = 22;
    camTheta = 0;
    camPhi = 20 * Math.PI / 180;
    camTarget.set(0, 4, 0);
    syncSlidersFromCamera();
  });

  // Mousemove for tooltip raycasting
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouseVec.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouseVec.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

    const tooltip = $('tooltip');
    tooltip.style.left = (e.clientX - rect.left + 16) + 'px';
    tooltip.style.top = (e.clientY - rect.top - 20) + 'px';
  });

  canvas.addEventListener('mouseleave', () => {
    mouseVec.set(-999, -999);
    hideTooltip();
  });
}

function updateCamera() {
  const x = camDist * Math.sin(camTheta) * Math.cos(camPhi);
  const y = camDist * Math.sin(camPhi);
  const z = camDist * Math.cos(camTheta) * Math.cos(camPhi);
  camera.position.set(camTarget.x + x, camTarget.y + y, camTarget.z + z);
  camera.lookAt(camTarget);
}

function syncSlidersFromCamera() {
  $('sliderZoom').value = Math.round(camDist);
  $('sliderElevation').value = Math.round(camPhi * 180 / Math.PI);
  $('sliderAngle').value = Math.round(camTheta * 180 / Math.PI);
}

// Sliders update camera
$('sliderZoom').addEventListener('input', e => {
  camDist = parseFloat(e.target.value);
});
$('sliderElevation').addEventListener('input', e => {
  camPhi = parseFloat(e.target.value) * Math.PI / 180;
});
$('sliderAngle').addEventListener('input', e => {
  camTheta = parseFloat(e.target.value) * Math.PI / 180;
});
$('sliderSensitivity').addEventListener('input', e => {
  settings.sensitivity = parseInt(e.target.value);
});
$('sliderSmoothing').addEventListener('input', e => {
  settings.smoothing = parseInt(e.target.value);
});

// ======================================================
//  ANIMATION LOOP
// ======================================================
function startVisualization() {
  if (animationId) cancelAnimationFrame(animationId);

  function animate() {
    animationId = requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    updateCamera();

    // Animate meshes (gentle floating)
    elementGroups.forEach(g => {
      if (!g.group.visible) return;

      const floatY = Math.sin(time * 0.6 + g.index * 1.7) * 0.12;
      g.group.position.y = g.baseY + floatY;

      // Subtle pulse
      const pulse = 1 + Math.sin(time * 1.0 + g.index * 2.3) * 0.025;
      g.mesh.scale.setScalar(pulse);
      g.glow.scale.setScalar(pulse);

      // Ring rotation
      g.ring.rotation.z = time * 0.3 + g.index;
    });

    // Raycasting for hover
    const meshes = elementGroups.filter(g => g.group.visible).map(g => g.mesh);
    raycaster.setFromCamera(mouseVec, camera);
    const intersects = raycaster.intersectObjects(meshes);

    if (hoveredMesh && (!intersects[0] || intersects[0].object !== hoveredMesh)) {
      const hg = elementGroups.find(g => g.mesh === hoveredMesh);
      if (hg) {
        hg.mesh.material.emissiveIntensity = 0.2;
        hg.ring.material.opacity = 0.25;
      }
      hoveredMesh = null;
      hideTooltip();
    }

    if (intersects.length > 0 && intersects[0].object !== hoveredMesh) {
      hoveredMesh = intersects[0].object;
      const hg = elementGroups.find(g => g.mesh === hoveredMesh);
      if (hg) {
        hg.mesh.material.emissiveIntensity = 0.6;
        hg.ring.material.opacity = 0.6;
        showTooltip(hg);
      }
    }

    // Progress bar
    if (isPlaying && audioBuffer) {
      const elapsed = audioCtx.currentTime - playStartTime + playOffset;
      const pct = Math.min(100, (elapsed / audioBuffer.duration) * 100);
      $('progressBar').style.width = pct + '%';
      if (elapsed >= audioBuffer.duration) stopPlayback();
    }

    renderer.render(scene, camera);
  }

  animate();
}

// ======================================================
//  TOOLTIP
// ======================================================
function showTooltip(g) {
  const el = g.element;
  const tooltip = $('tooltip');
  tooltip.style.display = 'block';
  tooltip.querySelector('.tt-name').textContent = el.name;
  tooltip.querySelector('.tt-name').style.color = el.color;

  $('ttVol').textContent = Math.round((el.normalizedVol || 0) * 100) + '% (' + el.dbDisplay + ' dB)';

  const bar = $('ttVolBar');
  bar.style.width = Math.round((el.normalizedVol || 0) * 100) + '%';
  bar.style.background = el.color;

  $('ttPan').textContent = el.pan < -0.1 ? `Gauche ${Math.round(Math.abs(el.pan)*100)}%` :
                           el.pan > 0.1 ? `Droite ${Math.round(el.pan*100)}%` : 'Centre';

  $('ttFreq').textContent = formatFreqRange(el.freqRange);

  const depthPct = Math.round(el.depthHint * 100);
  $('ttDepth').textContent = depthPct < 25 ? `Devant (${depthPct}%)` :
                             depthPct > 60 ? `Arriere (${depthPct}%)` :
                             `Milieu (${depthPct}%)`;
}

function hideTooltip() {
  $('tooltip').style.display = 'none';
}

function formatFreqRange(range) {
  const fmt = f => f >= 1000 ? (f/1000).toFixed(1) + 'k' : f + '';
  return fmt(range[0]) + ' – ' + fmt(range[1]) + ' Hz';
}

// ======================================================
//  PLAYBACK
// ======================================================
$('btnPlay').addEventListener('click', startPlayback);
$('btnPause').addEventListener('click', stopPlayback);
$('btnLive').addEventListener('click', toggleLiveMode);

function startPlayback() {
  if (!audioBuffer || isPlaying) return;
  const ctx = getAudioContext();
  ctx.resume();

  sourceNode = ctx.createBufferSource();
  sourceNode.buffer = audioBuffer;

  splitter = ctx.createChannelSplitter(2);
  analyserL = ctx.createAnalyser();
  analyserR = ctx.createAnalyser();
  analyserL.fftSize = 2048;
  analyserR.fftSize = 2048;
  analyserL.smoothingTimeConstant = settings.smoothing / 100;
  analyserR.smoothingTimeConstant = settings.smoothing / 100;

  sourceNode.connect(splitter);
  sourceNode.connect(ctx.destination);
  splitter.connect(analyserL, 0);
  splitter.connect(analyserR, 1);

  playStartTime = ctx.currentTime;
  sourceNode.start(0, playOffset);
  isPlaying = true;
  $('btnPlay').classList.add('active');
  $('btnPause').classList.remove('active');

  if (liveMode) startLiveUpdate();

  sourceNode.onended = () => {
    if (isPlaying) {
      isPlaying = false;
      playOffset = 0;
      $('progressBar').style.width = '0%';
      $('btnPlay').classList.remove('active');
    }
  };
}

function stopPlayback() {
  if (!isPlaying) return;
  playOffset = audioCtx.currentTime - playStartTime + playOffset;
  if (sourceNode) { sourceNode.onended = null; sourceNode.stop(); }
  isPlaying = false;
  $('btnPlay').classList.remove('active');
  $('btnPause').classList.add('active');
}

function toggleLiveMode() {
  liveMode = !liveMode;
  $('btnLive').classList.toggle('active', liveMode);
  if (liveMode && isPlaying) startLiveUpdate();
}

function startLiveUpdate() {
  if (!liveMode || !isPlaying || !analyserL || !analyserR) return;

  const bufLen = analyserL.frequencyBinCount;
  const dataL = new Float32Array(bufLen);
  const dataR = new Float32Array(bufLen);

  function update() {
    if (!liveMode || !isPlaying) return;

    analyserL.getFloatFrequencyData(dataL);
    analyserR.getFloatFrequencyData(dataR);

    const sr = audioCtx.sampleRate;
    const fft = analyserL.fftSize;

    elementGroups.forEach((g, i) => {
      if (!g.group.visible) return;
      const el = g.element;
      const lowBin = Math.max(0, Math.floor(el.freqRange[0] * fft / sr));
      const highBin = Math.min(bufLen - 1, Math.floor(el.freqRange[1] * fft / sr));

      let sL = 0, sR = 0, c = 0;
      for (let b = lowBin; b <= highBin; b++) {
        sL += Math.pow(10, dataL[b] / 20);
        sR += Math.pow(10, dataR[b] / 20);
        c++;
      }
      if (c > 0) { sL /= c; sR /= c; }

      const energy = (sL + sR) / 2;
      const dynamicScale = Math.min(2.5, Math.max(0.3, energy * 6));
      const tgt = dynamicScale;
      g.mesh.scale.lerp(new THREE.Vector3(tgt, tgt, tgt), 0.15);
      g.glow.scale.lerp(new THREE.Vector3(tgt * 1.4, tgt * 1.4, tgt * 1.4), 0.15);
      g.ring.scale.lerp(new THREE.Vector3(tgt, tgt, tgt), 0.15);
      g.glow.material.opacity = Math.min(0.15, energy * 0.3);

      // Live pan
      const tot = sL + sR;
      if (tot > 0.001) {
        const livePan = (sR - sL) / tot;
        g.group.position.x += (livePan * SCENE_WIDTH - g.group.position.x) * 0.05;
      }
    });

    requestAnimationFrame(update);
  }

  update();
}

// ======================================================
//  RESIZE
// ======================================================
function onResize() {
  if (!renderer) return;
  const wrap = $('canvas-wrap');
  const w = wrap.clientWidth;
  const h = wrap.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
}

// ======================================================
//  SHOW ALL / RESET
// ======================================================
$('btnShowAll').addEventListener('click', () => {
  hiddenIds.clear();
  updateInstrumentList();
  updateMeshVisibility();
});

$('btnReset').addEventListener('click', () => {
  if (isPlaying) stopPlayback();
  audioBuffer = null;
  sourceNode = null;
  detectedElements = [];
  hiddenIds.clear();
  playOffset = 0;

  if (renderer) {
    while(scene.children.length > 0) scene.remove(scene.children[0]);
    elementGroups = [];
    renderer.dispose();
    renderer = null;
  }

  $('emptyState').style.display = 'flex';
  $('hudBottom').style.display = 'none';
  $('transport').style.display = 'none';
  $('panelInstruments').style.display = 'none';
  $('controlsHelp').style.display = 'none';
  $('freqLegend').style.display = 'none';
  $('depthLegend').style.display = 'none';
  $('instrumentList').innerHTML = '';
  $('fileName').textContent = '';
  $('progressBar').style.width = '0%';
  canvas.width = 0;
  canvas.height = 0;
});

})();
</script>
</body>
</html>
