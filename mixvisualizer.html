<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mix Visualizer 3D</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  :root {
    --bg: #08080d;
    --surface: #101018;
    --surface2: #16161f;
    --surface3: #1c1c2a;
    --border: #252535;
    --text: #e8e8f0;
    --text-dim: #777799;
    --accent: #00d9ce;
    --accent2: #e91e8c;
    --accent3: #7c5cfc;
    --green: #34d399;
    --yellow: #fbbf24;
    --red: #f87171;
  }
  body {
    font-family: 'Inter', -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    user-select: none;
  }
  #app {
    display: grid;
    grid-template-rows: 44px 1fr;
    grid-template-columns: 280px 1fr;
    height: 100vh;
  }
  #app.compare-mode {
    grid-template-columns: 280px 1fr 1fr;
  }

  /* --- Top Bar --- */
  #topbar {
    grid-column: 1 / -1;
    display: flex; align-items: center; justify-content: space-between;
    padding: 0 16px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    z-index: 100;
  }
  #topbar .logo { display: flex; align-items: center; gap: 8px; font-weight: 700; font-size: 13px; }
  #topbar .logo svg { width: 22px; height: 22px; }
  #topbar .actions { display: flex; align-items: center; gap: 6px; }

  .btn {
    display: inline-flex; align-items: center; gap: 5px;
    padding: 5px 12px; border-radius: 5px;
    border: 1px solid var(--border); background: var(--surface2);
    color: var(--text); font-family: inherit; font-size: 11px; font-weight: 500;
    cursor: pointer; transition: all .15s; white-space: nowrap;
  }
  .btn:hover { background: var(--surface3); }
  .btn.active { background: var(--accent); color: #000; border-color: var(--accent); }
  .btn svg { width: 12px; height: 12px; flex-shrink: 0; }

  /* --- Sidebar --- */
  #sidebar {
    background: var(--surface);
    border-right: 1px solid var(--border);
    overflow-y: auto; padding: 10px;
    display: flex; flex-direction: column; gap: 8px;
    scrollbar-width: thin; scrollbar-color: var(--border) transparent;
  }
  #sidebar::-webkit-scrollbar { width: 3px; }
  #sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .panel { background: var(--surface2); border: 1px solid var(--border); border-radius: 8px; padding: 10px; }
  .panel h3 {
    font-size: 9px; text-transform: uppercase; letter-spacing: 0.1em;
    color: var(--text-dim); margin-bottom: 8px;
    display: flex; align-items: center; justify-content: space-between;
  }
  .panel h3 .badge {
    font-size: 8px; background: var(--surface3); padding: 1px 5px;
    border-radius: 3px; font-weight: 600; color: var(--accent);
  }

  /* Upload */
  .dropzone {
    border: 2px dashed var(--border); border-radius: 8px;
    padding: 16px 10px; text-align: center; cursor: pointer; transition: all .2s;
  }
  .dropzone:hover, .dropzone.dragover { border-color: var(--accent); background: rgba(0,217,206,0.04); }
  .dropzone p { font-size: 11px; color: var(--text-dim); }
  .dropzone .filename { font-size: 10px; color: var(--accent); margin-top: 4px; word-break: break-all; }
  .file-input { display: none; }

  /* Upload tabs for compare */
  .upload-tabs { display: flex; gap: 4px; margin-bottom: 6px; }
  .upload-tab {
    flex: 1; padding: 4px 8px; text-align: center; font-size: 10px; font-weight: 600;
    border-radius: 5px; border: 1px solid var(--border); background: var(--surface);
    cursor: pointer; color: var(--text-dim); transition: all .15s;
  }
  .upload-tab.active { background: var(--accent); color: #000; border-color: var(--accent); }

  /* Instrument list */
  .instrument-list { display: flex; flex-direction: column; gap: 2px; }
  .instrument-item {
    display: flex; align-items: center; gap: 6px;
    padding: 5px 6px; border-radius: 5px;
    background: rgba(255,255,255,0.02); font-size: 11px;
    transition: all .15s; cursor: pointer;
  }
  .instrument-item:hover { background: rgba(255,255,255,0.05); }
  .instrument-item.hidden-el { opacity: 0.25; }
  .instrument-item.hidden-el .instrument-name { text-decoration: line-through; }

  .eye-toggle {
    width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;
    cursor: pointer; opacity: 0.4; transition: opacity .15s; flex-shrink: 0;
  }
  .eye-toggle:hover { opacity: 1; }
  .eye-toggle svg { width: 12px; height: 12px; }

  .color-swatch {
    width: 14px; height: 14px; border-radius: 3px; flex-shrink: 0;
    cursor: pointer; border: 1px solid rgba(255,255,255,0.1);
    transition: transform .1s;
  }
  .color-swatch:hover { transform: scale(1.2); }
  .color-input { position: absolute; opacity: 0; width: 0; height: 0; }
  .instrument-name { flex: 1; font-weight: 500; font-size: 10px; }

  .vol-bar-wrap {
    width: 40px; height: 5px; background: var(--surface);
    border-radius: 3px; overflow: hidden; flex-shrink: 0;
  }
  .vol-bar { height: 100%; border-radius: 3px; transition: width .3s; }
  .instrument-db {
    font-size: 8px; color: var(--text-dim); width: 32px;
    text-align: right; font-variant-numeric: tabular-nums; flex-shrink: 0;
  }
  .instrument-pan-badge {
    font-size: 8px; color: var(--text-dim); background: var(--surface);
    padding: 1px 4px; border-radius: 3px; font-weight: 600;
    flex-shrink: 0; min-width: 18px; text-align: center;
  }

  /* Confidence badge */
  .confidence-badge {
    font-size: 7px; padding: 1px 3px; border-radius: 2px;
    font-weight: 700; flex-shrink: 0;
  }
  .confidence-high { background: rgba(52,211,153,0.2); color: var(--green); }
  .confidence-mid { background: rgba(251,191,36,0.2); color: var(--yellow); }
  .confidence-low { background: rgba(248,113,113,0.2); color: var(--red); }

  .slider-row { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
  .slider-row:last-child { margin-bottom: 0; }
  .slider-row label { font-size: 10px; color: var(--text-dim); width: 60px; flex-shrink: 0; }
  .slider-row input[type=range] {
    flex: 1; -webkit-appearance: none; height: 3px;
    border-radius: 2px; background: var(--border); outline: none;
  }
  .slider-row input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 10px; height: 10px; border-radius: 50%;
    background: var(--accent); cursor: pointer; border: 2px solid var(--surface);
  }

  .analyzing-overlay {
    position: absolute; inset: 0; display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: rgba(8,8,13,0.9); z-index: 200; gap: 12px;
  }
  .analyzing-overlay .spinner {
    width: 32px; height: 32px; border: 3px solid var(--border);
    border-top-color: var(--accent); border-radius: 50%; animation: spin 0.7s linear infinite;
  }
  .analyzing-overlay .progress-text {
    font-size: 11px; color: var(--text-dim);
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Canvas areas */
  .canvas-wrap {
    position: relative; overflow: hidden; background: var(--bg);
  }
  .canvas-wrap canvas { display: block; }
  .canvas-wrap .label-overlay {
    position: absolute; top: 8px; left: 8px;
    font-size: 10px; font-weight: 700; color: var(--text-dim);
    background: rgba(16,16,24,0.8); padding: 3px 8px; border-radius: 4px;
    border: 1px solid var(--border); z-index: 5;
  }

  .controls-help {
    position: absolute; top: 8px; right: 8px;
    display: flex; flex-direction: column; gap: 2px;
    font-size: 9px; color: var(--text-dim);
    background: rgba(16,16,24,0.8); backdrop-filter: blur(8px);
    padding: 6px 10px; border-radius: 6px; border: 1px solid var(--border);
    pointer-events: none; opacity: 0.6; z-index: 10;
  }
  .controls-help kbd {
    display: inline-block; background: var(--surface3); border: 1px solid var(--border);
    border-radius: 2px; padding: 0 3px; font-family: inherit; font-size: 8px; color: var(--text);
  }

  #tooltip {
    position: fixed; display: none; pointer-events: none;
    background: rgba(16,16,24,0.95); backdrop-filter: blur(12px);
    border: 1px solid var(--border); border-radius: 8px;
    padding: 10px 14px; font-size: 11px; z-index: 500; min-width: 170px;
  }
  #tooltip .tt-name { font-weight: 700; font-size: 14px; margin-bottom: 6px; }
  #tooltip .tt-row { display: flex; justify-content: space-between; gap: 12px; color: var(--text-dim); margin-top: 2px; }
  #tooltip .tt-val { color: var(--text); font-weight: 600; font-variant-numeric: tabular-nums; }
  #tooltip .tt-volbar { width: 100%; height: 5px; background: var(--surface3); border-radius: 3px; margin-top: 6px; overflow: hidden; }
  #tooltip .tt-volbar-fill { height: 100%; border-radius: 3px; }

  .transport {
    position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 5px; z-index: 30;
  }
  .transport button {
    width: 32px; height: 32px; border-radius: 50%;
    border: 1px solid var(--border); background: rgba(16,16,24,0.9);
    color: var(--text); cursor: pointer; display: flex; align-items: center; justify-content: center;
    transition: all .15s; backdrop-filter: blur(8px);
  }
  .transport button:hover { border-color: var(--accent); color: var(--accent); }
  .transport button.active { background: var(--accent); color: #000; border-color: var(--accent); }
  .transport button svg { width: 12px; height: 12px; }

  .hud-bottom {
    position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 16px;
    background: rgba(16,16,24,0.8); backdrop-filter: blur(8px);
    padding: 4px 14px; border-radius: 12px; border: 1px solid var(--border);
    pointer-events: none; font-size: 9px; color: var(--text-dim); z-index: 10;
  }

  .empty-state {
    position: absolute; inset: 0; display: flex; flex-direction: column;
    align-items: center; justify-content: center; gap: 10px; color: var(--text-dim);
  }
  .empty-state svg { opacity: 0.15; }
  .empty-state p { font-size: 12px; }

  .progress-bar {
    position: absolute; bottom: 0; left: 0; height: 2px;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    transition: width 0.1s linear; z-index: 10;
  }

  @media (max-width: 900px) {
    #app, #app.compare-mode { grid-template-columns: 1fr; }
    #sidebar { display: none; }
  }
</style>
</head>
<body>
<div id="app">
  <div id="topbar">
    <div class="logo">
      <svg viewBox="0 0 28 28" fill="none">
        <circle cx="14" cy="14" r="13" stroke="currentColor" stroke-width="1.5" opacity="0.3"/>
        <circle cx="14" cy="14" r="6" fill="url(#g1)"/>
        <circle cx="14" cy="8" r="2.5" fill="url(#g2)"/>
        <circle cx="9" cy="18" r="3.5" fill="url(#g3)" opacity="0.7"/>
        <circle cx="19" cy="17" r="2" fill="url(#g4)" opacity="0.6"/>
        <defs>
          <radialGradient id="g1"><stop stop-color="#7c5cfc"/><stop offset="1" stop-color="#5c3cdc"/></radialGradient>
          <radialGradient id="g2"><stop stop-color="#e91e8c"/><stop offset="1" stop-color="#c9006c"/></radialGradient>
          <radialGradient id="g3"><stop stop-color="#00d9ce"/><stop offset="1" stop-color="#00a99e"/></radialGradient>
          <radialGradient id="g4"><stop stop-color="#ffd600"/><stop offset="1" stop-color="#ffaa00"/></radialGradient>
        </defs>
      </svg>
      Mix Visualizer 3D
    </div>
    <div class="actions">
      <button class="btn" id="btnCompare">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="18" rx="1"/><rect x="14" y="3" width="7" height="18" rx="1"/></svg>
        Comparer
      </button>
      <button class="btn" id="btnShowAll">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
        Tout afficher
      </button>
      <button class="btn" id="btnReset">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 4v6h6M23 20v-6h-6"/><path d="M20.49 9A9 9 0 005.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 013.51 15"/></svg>
        Reset
      </button>
    </div>
  </div>

  <div id="sidebar">
    <!-- Upload tabs for compare mode -->
    <div class="upload-tabs" id="uploadTabs" style="display:none">
      <div class="upload-tab active" data-slot="0">Piste A</div>
      <div class="upload-tab" data-slot="1">Piste B</div>
    </div>

    <div class="dropzone" id="dropzone0">
      <p>Glisser un audio ici ou <strong style="color:var(--accent)">parcourir</strong></p>
      <p style="font-size:9px;margin-top:2px;opacity:0.4">WAV, MP3, FLAC, OGG</p>
      <div class="filename" id="fileName0"></div>
    </div>
    <input type="file" class="file-input" id="fileInput0" accept="audio/*">

    <div class="dropzone" id="dropzone1" style="display:none">
      <p>Audio B : <strong style="color:var(--accent2)">parcourir</strong></p>
      <div class="filename" id="fileName1"></div>
    </div>
    <input type="file" class="file-input" id="fileInput1" accept="audio/*">

    <div class="panel" id="panelInstruments" style="display:none">
      <h3>Elements detectes <span class="badge" id="elCount">0</span></h3>
      <div class="instrument-list" id="instrumentList"></div>
    </div>

    <div class="panel">
      <h3>Camera</h3>
      <div class="slider-row"><label>Zoom</label><input type="range" id="sliderZoom" min="4" max="40" value="14"></div>
      <div class="slider-row"><label>Elevation</label><input type="range" id="sliderElevation" min="-10" max="80" value="25"></div>
      <div class="slider-row"><label>Angle</label><input type="range" id="sliderAngle" min="-180" max="180" value="0"></div>
    </div>

    <div class="panel">
      <h3>Analyse</h3>
      <div class="slider-row"><label>Sensibilite</label><input type="range" id="sliderThreshold" min="1" max="100" value="50"></div>
    </div>

    <div class="panel">
      <h3>Axes</h3>
      <div style="font-size:10px;color:var(--text-dim);line-height:1.9">
        <div><span style="color:var(--accent)">&#8594;</span> <b style="color:var(--text)">X</b> Stereo (L / R)</div>
        <div><span style="color:var(--accent2)">&#8593;</span> <b style="color:var(--text)">Y</b> Frequence (grave / aigu)</div>
        <div><span style="color:var(--accent3)">&#9679;</span> <b style="color:var(--text)">Taille</b> Volume (dB)</div>
        <div><span style="color:var(--yellow)">&#8599;</span> <b style="color:var(--text)">Z</b> Profondeur (dry / wet)</div>
      </div>
    </div>
  </div>

  <!-- Canvas A (always visible) -->
  <div class="canvas-wrap" id="canvasWrap0">
    <div class="empty-state" id="emptyState0">
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><circle cx="12" cy="12" r="10"/><path d="M12 8v4l3 3"/></svg>
      <p>Importer un fichier audio</p>
    </div>
    <canvas id="scene0"></canvas>
    <div class="controls-help" id="controlsHelp0" style="display:none">
      <div><kbd>Clic G</kbd> Orbite &nbsp; <kbd>Clic D</kbd> Pan &nbsp; <kbd>Molette</kbd> Zoom</div>
    </div>
    <div class="hud-bottom" id="hud0" style="display:none">
      <span>&#8592; L &#8212; R &#8594;</span><span>&#8595; Grave &#8212; Aigu &#8593;</span><span>Taille = Volume</span>
    </div>
    <div class="transport" id="transport0" style="display:none">
      <button class="btnPlay" data-slot="0" title="Play"><svg viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg></button>
      <button class="btnPause" data-slot="0" title="Pause"><svg viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg></button>
      <button class="btnLive" data-slot="0" title="Live"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-4 0v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06A1.65 1.65 0 004.68 15a1.65 1.65 0 00-1.51-1H3a2 2 0 010-4h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 009 4.68a1.65 1.65 0 001-1.51V3a2 2 0 014 0v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 9a1.65 1.65 0 001.51 1H21a2 2 0 010 4h-.09a1.65 1.65 0 00-1.51 1z"/></svg></button>
    </div>
    <div class="progress-bar" id="progressBar0" style="width:0%"></div>
  </div>

  <!-- Canvas B (compare mode only) -->
  <div class="canvas-wrap" id="canvasWrap1" style="display:none">
    <div class="label-overlay" style="color:var(--accent2)">PISTE B</div>
    <div class="empty-state" id="emptyState1">
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><circle cx="12" cy="12" r="10"/><path d="M12 8v4l3 3"/></svg>
      <p>Importer audio B</p>
    </div>
    <canvas id="scene1"></canvas>
    <div class="transport" id="transport1" style="display:none">
      <button class="btnPlay" data-slot="1" title="Play"><svg viewBox="0 0 24 24" fill="currentColor"><polygon points="5,3 19,12 5,21"/></svg></button>
      <button class="btnPause" data-slot="1" title="Pause"><svg viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg></button>
    </div>
    <div class="progress-bar" id="progressBar1" style="width:0%"></div>
  </div>
</div>

<div id="tooltip">
  <div class="tt-name"></div>
  <div class="tt-row"><span>Volume</span><span class="tt-val" id="ttVol"></span></div>
  <div class="tt-volbar"><div class="tt-volbar-fill" id="ttVolBar"></div></div>
  <div class="tt-row"><span>Pan</span><span class="tt-val" id="ttPan"></span></div>
  <div class="tt-row"><span>Frequences</span><span class="tt-val" id="ttFreq"></span></div>
  <div class="tt-row"><span>Profondeur</span><span class="tt-val" id="ttDepth"></span></div>
  <div class="tt-row"><span>Confiance</span><span class="tt-val" id="ttConf"></span></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function() {
'use strict';

// ======== INSTRUMENT DEFINITIONS ========
// Redesigned: fewer instruments, stricter bands, HPSS-aware classification
const INSTRUMENT_DEFS = [
  { id:'sub',    name:'Sub Bass',      color:'#7c5cfc', freqRange:[20,80],    yPos:0.04, depth:0.3, type:'harmonic',   bandHz:[20,80] },
  { id:'kick',   name:'Kick',          color:'#d4a053', freqRange:[40,150],   yPos:0.10, depth:0.15,type:'percussive', bandHz:[30,150] },
  { id:'bass',   name:'Bass',          color:'#00c9a7', freqRange:[60,300],   yPos:0.20, depth:0.2, type:'harmonic',   bandHz:[80,300] },
  { id:'snare',  name:'Snare',         color:'#e63946', freqRange:[150,1000], yPos:0.38, depth:0.25,type:'percussive', bandHz:[150,900] },
  { id:'keys',   name:'Keys / Piano',  color:'#f4a261', freqRange:[200,4000], yPos:0.48, depth:0.45,type:'harmonic',   bandHz:[300,2000] },
  { id:'vocal',  name:'Lead Vocal',    color:'#a78bfa', freqRange:[200,6000], yPos:0.55, depth:0.1, type:'harmonic',   bandHz:[250,4500] },
  { id:'guitar', name:'Guitare',       color:'#2a9d8f', freqRange:[80,5000],  yPos:0.50, depth:0.4, type:'harmonic',   bandHz:[200,3500] },
  { id:'clap',   name:'Clap / Perc',   color:'#ffd166', freqRange:[300,8000], yPos:0.54, depth:0.3, type:'percussive', bandHz:[800,8000] },
  { id:'bgv',    name:'BGV / Choeurs', color:'#e91e8c', freqRange:[300,6000], yPos:0.60, depth:0.6, type:'harmonic',   bandHz:[400,5000] },
  { id:'synth',  name:'Synth / Pad',   color:'#4cc9f0', freqRange:[80,10000], yPos:0.52, depth:0.55,type:'harmonic',   bandHz:[150,8000] },
  { id:'hihat',  name:'Hi-Hats',       color:'#b5e48c', freqRange:[5000,18000],yPos:0.82, depth:0.2, type:'percussive', bandHz:[5000,16000] },
  { id:'cymbal', name:'Cymbales',      color:'#d0d0d0', freqRange:[3000,20000],yPos:0.90, depth:0.35,type:'percussive', bandHz:[3000,18000] },
  { id:'air',    name:'Air / Brillance',color:'#f0f0ff', freqRange:[8000,20000],yPos:0.96, depth:0.7, type:'harmonic',   bandHz:[10000,20000] },
];

const FREQ_ZONES = [
  { label:'Sub',      color:'#7c5cfc', y0:0,    y1:0.06 },
  { label:'Bass',     color:'#a78bfa', y0:0.06, y1:0.22 },
  { label:'Low-Mid',  color:'#60a5fa', y0:0.22, y1:0.42 },
  { label:'Mediums',  color:'#34d399', y0:0.42, y1:0.72 },
  { label:'Presence', color:'#fbbf24', y0:0.72, y1:0.86 },
  { label:'Air',      color:'#f87171', y0:0.86, y1:1.0  },
];

// Compact scene
const SH = 8;
const SW = 6;
const SD = 5;

// ======== STATE (per slot) ========
const slots = [
  { audioCtx:null, audioBuffer:null, source:null, analyserL:null, analyserR:null, splitter:null,
    isPlaying:false, playStart:0, playOff:0, elements:[], hiddenIds:new Set(), liveMode:false,
    scene:null, camera:null, renderer:null, groups:[], animId:null,
    camDist:14, camTheta:0, camPhi:25*Math.PI/180, camTarget:new THREE.Vector3(0,2.5,0),
    dragging:false, panning:false, lastX:0, lastY:0, hovered:null },
  { audioCtx:null, audioBuffer:null, source:null, analyserL:null, analyserR:null, splitter:null,
    isPlaying:false, playStart:0, playOff:0, elements:[], hiddenIds:new Set(), liveMode:false,
    scene:null, camera:null, renderer:null, groups:[], animId:null,
    camDist:14, camTheta:0, camPhi:25*Math.PI/180, camTarget:new THREE.Vector3(0,2.5,0),
    dragging:false, panning:false, lastX:0, lastY:0, hovered:null },
];

let compareMode = false;
let activeSlot = 0;
let customColors = {};
let sensitivitySetting = 50;

const $ = id => document.getElementById(id);
const mouse = new THREE.Vector2(-999,-999);
const raycaster = new THREE.Raycaster();

// ======== COLOR PERSISTENCE ========
try { const c = JSON.parse(localStorage.getItem('mixviz_colors')||'{}'); if(c) customColors=c; } catch(e){}
function saveColors() { try { localStorage.setItem('mixviz_colors', JSON.stringify(customColors)); } catch(e){} }
function getColor(id) { return customColors[id] || INSTRUMENT_DEFS.find(d=>d.id===id)?.color || '#888'; }

// ======== FILE LOADING ========
[0,1].forEach(slot => {
  const dz = $('dropzone'+slot);
  const fi = $('fileInput'+slot);
  dz.addEventListener('click', () => fi.click());
  dz.addEventListener('dragover', e => { e.preventDefault(); dz.classList.add('dragover'); });
  dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
  dz.addEventListener('drop', e => { e.preventDefault(); dz.classList.remove('dragover'); if(e.dataTransfer.files.length) loadFile(slot, e.dataTransfer.files[0]); });
  fi.addEventListener('change', e => { if(e.target.files.length) loadFile(slot, e.target.files[0]); });
});

async function loadFile(slot, file) {
  $('fileName'+slot).textContent = file.name;
  const s = slots[slot];
  if (!s.audioCtx) s.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  showAnalyzing(slot, true, 'Decodage audio...');
  try {
    const buf = await file.arrayBuffer();
    s.audioBuffer = await s.audioCtx.decodeAudioData(buf);
    s.hiddenIds.clear();
    showAnalyzing(slot, true, 'Analyse spectrale STFT...');
    // Run analysis async to not block UI
    await new Promise(r => setTimeout(r, 50));
    analyzeAudioAdvanced(slot);
    $('emptyState'+slot).style.display = 'none';
    $('transport'+slot).style.display = 'flex';
    if(slot===0) { $('hud0').style.display='flex'; $('controlsHelp0').style.display='block'; $('panelInstruments').style.display='block'; }
    initScene(slot);
    buildMeshes(slot);
    startRenderLoop(slot);
    if(slot===activeSlot) updateInstrumentList();
  } catch(err) {
    console.error(err);
    alert('Erreur chargement audio: ' + err.message);
  }
  showAnalyzing(slot, false);
}

function showAnalyzing(slot, show, msg) {
  const wrap = $('canvasWrap'+slot);
  let el = wrap.querySelector('.analyzing-overlay');
  if(show && !el) {
    el=document.createElement('div');
    el.className='analyzing-overlay';
    el.innerHTML=`<div class="spinner"></div><p class="progress-text">${msg||'Analyse...'}</p>`;
    wrap.appendChild(el);
  } else if(show && el) {
    const pt = el.querySelector('.progress-text');
    if(pt) pt.textContent = msg||'Analyse...';
  } else if(!show && el) {
    el.remove();
  }
}

// ================================================================
// ======== ADVANCED AUDIO ANALYSIS WITH STFT + HPSS ========
// ================================================================

function analyzeAudioAdvanced(slot) {
  const s = slots[slot];
  const buf = s.audioBuffer;
  if(!buf) return;

  const sr = buf.sampleRate;
  const dL = buf.getChannelData(0);
  const dR = buf.numberOfChannels > 1 ? buf.getChannelData(1) : dL;
  const len = dL.length;

  // STFT parameters
  const fftSize = 4096;
  const hopSize = fftSize / 2; // 50% overlap
  const binCount = fftSize / 2;
  const numFrames = Math.min(200, Math.floor((len - fftSize) / hopSize));
  if(numFrames < 2) return;

  // Hann window
  const win = new Float32Array(fftSize);
  for(let i = 0; i < fftSize; i++) win[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (fftSize - 1)));

  // ---- Step 1: Compute full STFT magnitude spectrogram ----
  // spectrogramL[frame][bin], spectrogramR[frame][bin]
  const spectrogramL = [];
  const spectrogramR = [];

  for(let f = 0; f < numFrames; f++) {
    const offset = f * hopSize;
    // Apply window and compute FFT via DFT for key bins
    // For efficiency, we compute the full spectrum using a radix-2 FFT approach
    const magL = computeFFTMagnitude(dL, offset, fftSize, win);
    const magR = computeFFTMagnitude(dR, offset, fftSize, win);
    spectrogramL.push(magL);
    spectrogramR.push(magR);
  }

  // ---- Step 2: HPSS (Harmonic/Percussive Source Separation) ----
  // Median filtering: horizontal median = harmonic, vertical median = percussive
  const medianKernel = 17; // must be odd
  const halfK = Math.floor(medianKernel / 2);

  // Compute combined spectrogram (mono) for HPSS
  const specMono = [];
  for(let f = 0; f < numFrames; f++) {
    const mono = new Float32Array(binCount);
    for(let b = 0; b < binCount; b++) {
      mono[b] = (spectrogramL[f][b] + spectrogramR[f][b]) / 2;
    }
    specMono.push(mono);
  }

  // Harmonic mask: median filter along time axis (horizontal) for each bin
  const harmonicSpec = [];
  for(let f = 0; f < numFrames; f++) {
    harmonicSpec.push(new Float32Array(binCount));
  }

  // Percussive mask: median filter along frequency axis (vertical) for each frame
  const percussiveSpec = [];
  for(let f = 0; f < numFrames; f++) {
    percussiveSpec.push(new Float32Array(binCount));
  }

  // Horizontal median (harmonic) - along time for each frequency bin
  for(let b = 0; b < binCount; b++) {
    const timeSlice = new Float32Array(numFrames);
    for(let f = 0; f < numFrames; f++) timeSlice[f] = specMono[f][b];
    const medH = medianFilter1D(timeSlice, medianKernel);
    for(let f = 0; f < numFrames; f++) harmonicSpec[f][b] = medH[f];
  }

  // Vertical median (percussive) - along frequency for each time frame
  for(let f = 0; f < numFrames; f++) {
    const freqSlice = specMono[f]; // already Float32Array
    const medV = medianFilter1D(freqSlice, medianKernel);
    for(let b = 0; b < binCount; b++) percussiveSpec[f][b] = medV[b];
  }

  // Soft mask: H_mask = H^2 / (H^2 + P^2), P_mask = P^2 / (H^2 + P^2)
  const harmonicMasked = [];
  const percussiveMasked = [];
  for(let f = 0; f < numFrames; f++) {
    const hm = new Float32Array(binCount);
    const pm = new Float32Array(binCount);
    for(let b = 0; b < binCount; b++) {
      const h2 = harmonicSpec[f][b] * harmonicSpec[f][b];
      const p2 = percussiveSpec[f][b] * percussiveSpec[f][b];
      const denom = h2 + p2 + 1e-10;
      hm[b] = specMono[f][b] * (h2 / denom);
      pm[b] = specMono[f][b] * (p2 / denom);
    }
    harmonicMasked.push(hm);
    percussiveMasked.push(pm);
  }

  // ---- Step 3: Compute spectral features per instrument band ----
  const sensitivity = sensitivitySetting / 100; // 0 to 1

  // Total energy in harmonic + percussive
  let totalHarmonicEnergy = 0;
  let totalPercussiveEnergy = 0;
  for(let f = 0; f < numFrames; f++) {
    for(let b = 0; b < binCount; b++) {
      totalHarmonicEnergy += harmonicMasked[f][b];
      totalPercussiveEnergy += percussiveMasked[f][b];
    }
  }
  totalHarmonicEnergy /= numFrames;
  totalPercussiveEnergy /= numFrames;
  const totalEnergy = totalHarmonicEnergy + totalPercussiveEnergy;

  s.elements = [];

  for(const def of INSTRUMENT_DEFS) {
    const loBin = Math.max(1, Math.round(def.bandHz[0] * fftSize / sr));
    const hiBin = Math.min(binCount - 1, Math.round(def.bandHz[1] * fftSize / sr));
    if(loBin >= hiBin) continue;

    const isPerc = def.type === 'percussive';
    const spec = isPerc ? percussiveMasked : harmonicMasked;
    const refTotal = isPerc ? totalPercussiveEnergy : totalHarmonicEnergy;

    // Average energy in this band from the appropriate HPSS component
    let bandEnergy = 0;
    let bandEnergyL = 0;
    let bandEnergyR = 0;
    const frameEnergies = new Float32Array(numFrames);

    for(let f = 0; f < numFrames; f++) {
      let fe = 0;
      let feL = 0;
      let feR = 0;
      for(let b = loBin; b <= hiBin; b++) {
        fe += spec[f][b];
        // Use original stereo spectrograms with HPSS mask ratio
        const h2 = harmonicSpec[f][b] * harmonicSpec[f][b];
        const p2 = percussiveSpec[f][b] * percussiveSpec[f][b];
        const denom = h2 + p2 + 1e-10;
        const maskRatio = isPerc ? (p2 / denom) : (h2 / denom);
        feL += spectrogramL[f][b] * maskRatio;
        feR += spectrogramR[f][b] * maskRatio;
      }
      frameEnergies[f] = fe;
      bandEnergy += fe;
      bandEnergyL += feL;
      bandEnergyR += feR;
    }
    bandEnergy /= numFrames;
    bandEnergyL /= numFrames;
    bandEnergyR /= numFrames;

    // Relative energy: how much of the relevant HPSS component is in this band
    const relEnergy = refTotal > 0 ? bandEnergy / refTotal : 0;

    // Spectral centroid in this band (average frequency weighted by energy)
    let centroidSum = 0;
    let centroidWeight = 0;
    for(let f = 0; f < numFrames; f++) {
      for(let b = loBin; b <= hiBin; b++) {
        const freq = b * sr / fftSize;
        centroidSum += freq * spec[f][b];
        centroidWeight += spec[f][b];
      }
    }
    const centroid = centroidWeight > 0 ? centroidSum / centroidWeight : 0;

    // Spectral flatness (geometric mean / arithmetic mean) - measures tonality
    // Lower = more tonal, Higher = more noise-like
    let logSum = 0;
    let linSum = 0;
    let flatCount = 0;
    for(let f = 0; f < numFrames; f++) {
      for(let b = loBin; b <= hiBin; b++) {
        const v = spec[f][b] + 1e-10;
        logSum += Math.log(v);
        linSum += v;
        flatCount++;
      }
    }
    const flatness = flatCount > 0 ? Math.exp(logSum / flatCount) / (linSum / flatCount + 1e-10) : 0;

    // Temporal variance (onset strength for percussive detection)
    const meanFrameE = frameEnergies.reduce((a, b) => a + b, 0) / numFrames;
    let variance = 0;
    for(let f = 0; f < numFrames; f++) {
      const d = frameEnergies[f] - meanFrameE;
      variance += d * d;
    }
    variance /= numFrames;
    const coeffOfVariation = meanFrameE > 0 ? Math.sqrt(variance) / meanFrameE : 0;

    // Spectral flux (onset detection - sum of positive frequency changes)
    let fluxTotal = 0;
    for(let f = 1; f < numFrames; f++) {
      let flux = 0;
      for(let b = loBin; b <= hiBin; b++) {
        const diff = spec[f][b] - spec[f-1][b];
        if(diff > 0) flux += diff;
      }
      fluxTotal += flux;
    }
    const avgFlux = fluxTotal / (numFrames - 1);
    const normalizedFlux = bandEnergy > 0 ? avgFlux / bandEnergy : 0;

    // ---- Confidence scoring ----
    // Dynamic threshold based on sensitivity
    const baseThreshold = 0.02 + (1 - sensitivity) * 0.12; // 0.02 to 0.14

    let confidence = 0;

    if(isPerc) {
      // Percussive elements need:
      // 1. Enough energy in the percussive HPSS component
      // 2. High temporal variance (transient character)
      // 3. High spectral flux (onsets)
      const energyOk = relEnergy > baseThreshold * 0.5;
      const transientOk = coeffOfVariation > 0.4;
      const fluxOk = normalizedFlux > 0.1;

      if(energyOk && (transientOk || fluxOk)) {
        const energyScore = Math.min(1, relEnergy / 0.15);
        const transientScore = Math.min(1, coeffOfVariation / 1.0);
        const fluxScore = Math.min(1, normalizedFlux / 0.5);
        confidence = energyScore * 0.4 + Math.max(transientScore, fluxScore) * 0.6;
      }
    } else {
      // Harmonic elements need:
      // 1. Enough energy in the harmonic HPSS component
      // 2. Lower spectral flatness (more tonal)
      const energyOk = relEnergy > baseThreshold;
      const tonal = flatness < 0.5; // fairly tonal

      if(energyOk) {
        const energyScore = Math.min(1, relEnergy / 0.2);
        const tonalBonus = tonal ? 1.0 : 0.5;
        confidence = energyScore * tonalBonus;
      }
    }

    // Minimum confidence cutoff
    const minConf = 0.08 + (1 - sensitivity) * 0.15;
    if(confidence < minConf) continue;
    confidence = Math.min(1, confidence);

    // Pan from stereo energy
    const totalLR = bandEnergyL + bandEnergyR;
    const pan = totalLR > 0 ? (bandEnergyR - bandEnergyL) / totalLR : 0;

    s.elements.push({
      id: def.id,
      name: def.name,
      color: getColor(def.id),
      freqRange: def.freqRange,
      bandHz: def.bandHz,
      yPos: def.yPos,
      depth: def.depth,
      defType: def.type,
      energy: bandEnergy,
      relEnergy,
      pan: Math.max(-1, Math.min(1, pan)),
      volumeDb: 20 * Math.log10(bandEnergy + 1e-10),
      confidence,
      centroid,
      flatness,
      coeffOfVariation,
      spectralFlux: normalizedFlux,
    });
  }

  // ---- Step 4: Resolve overlapping detections ----
  // If vocal AND guitar AND keys AND synth AND bgv are all detected,
  // it's likely just one source. Keep only the most confident ones.
  resolveOverlaps(s.elements);

  // Normalize volumes
  if(s.elements.length > 0) {
    const maxE = Math.max(...s.elements.map(e => e.energy));
    s.elements.forEach(e => {
      e.normalizedVol = Math.pow(e.energy / (maxE || 1), 0.35);
      e.dbDisplay = e.volumeDb.toFixed(1);
    });
  }
}

// Resolve overlapping harmonic detections
function resolveOverlaps(elements) {
  // Group: tonal mid-range instruments that easily overlap
  const midTonal = ['vocal', 'guitar', 'keys', 'synth', 'bgv'];
  const midDetected = elements.filter(e => midTonal.includes(e.id));

  // If more than 3 mid-tonal instruments detected, keep only top 2 by confidence
  if(midDetected.length > 3) {
    midDetected.sort((a, b) => b.confidence - a.confidence);
    const toRemove = midDetected.slice(2).map(e => e.id);
    for(let i = elements.length - 1; i >= 0; i--) {
      if(toRemove.includes(elements[i].id)) elements.splice(i, 1);
    }
  }

  // Group: sub-bass and kick often overlap
  const lowDetected = elements.filter(e => ['sub', 'kick', 'bass'].includes(e.id));
  if(lowDetected.length === 3) {
    // If all three detected, check if sub is really distinct from bass
    const sub = lowDetected.find(e => e.id === 'sub');
    const bass = lowDetected.find(e => e.id === 'bass');
    if(sub && bass && sub.confidence < bass.confidence * 0.5) {
      const idx = elements.indexOf(sub);
      if(idx >= 0) elements.splice(idx, 1);
    }
  }

  // Group: hihat and cymbal overlap heavily
  const hiDetected = elements.filter(e => ['hihat', 'cymbal'].includes(e.id));
  if(hiDetected.length === 2) {
    // Keep the more confident one
    hiDetected.sort((a, b) => b.confidence - a.confidence);
    if(hiDetected[1].confidence < hiDetected[0].confidence * 0.4) {
      const idx = elements.indexOf(hiDetected[1]);
      if(idx >= 0) elements.splice(idx, 1);
    }
  }
}

// ---- FFT via radix-2 Cooley-Tukey ----
function computeFFTMagnitude(data, offset, fftSize, win) {
  const n = fftSize;
  const re = new Float32Array(n);
  const im = new Float32Array(n);

  // Apply window
  for(let i = 0; i < n; i++) {
    const idx = offset + i;
    re[i] = idx < data.length ? data[idx] * win[i] : 0;
    im[i] = 0;
  }

  // Bit reversal
  let j = 0;
  for(let i = 0; i < n; i++) {
    if(i < j) {
      let tmp = re[i]; re[i] = re[j]; re[j] = tmp;
      tmp = im[i]; im[i] = im[j]; im[j] = tmp;
    }
    let m = n >> 1;
    while(m >= 1 && j >= m) { j -= m; m >>= 1; }
    j += m;
  }

  // FFT butterfly
  for(let size = 2; size <= n; size *= 2) {
    const halfSize = size / 2;
    const angle = -2 * Math.PI / size;
    const wRe = Math.cos(angle);
    const wIm = Math.sin(angle);

    for(let i = 0; i < n; i += size) {
      let curRe = 1, curIm = 0;
      for(let k = 0; k < halfSize; k++) {
        const tRe = curRe * re[i + k + halfSize] - curIm * im[i + k + halfSize];
        const tIm = curRe * im[i + k + halfSize] + curIm * re[i + k + halfSize];
        re[i + k + halfSize] = re[i + k] - tRe;
        im[i + k + halfSize] = im[i + k] - tIm;
        re[i + k] += tRe;
        im[i + k] += tIm;
        const newCurRe = curRe * wRe - curIm * wIm;
        curIm = curRe * wIm + curIm * wRe;
        curRe = newCurRe;
      }
    }
  }

  // Compute magnitudes for first half (positive frequencies)
  const mag = new Float32Array(n / 2);
  for(let i = 0; i < n / 2; i++) {
    mag[i] = Math.sqrt(re[i] * re[i] + im[i] * im[i]) / n;
  }
  return mag;
}

// 1D median filter
function medianFilter1D(arr, kernelSize) {
  const n = arr.length;
  const half = Math.floor(kernelSize / 2);
  const out = new Float32Array(n);
  const buf = new Float32Array(kernelSize);

  for(let i = 0; i < n; i++) {
    let count = 0;
    for(let k = -half; k <= half; k++) {
      const idx = Math.max(0, Math.min(n - 1, i + k));
      buf[count++] = arr[idx];
    }
    // Sort to find median
    const slice = buf.subarray(0, count);
    slice.sort();
    out[i] = slice[Math.floor(count / 2)];
  }
  return out;
}

// ======== SIDEBAR ========
function updateInstrumentList() {
  const s = slots[activeSlot];
  const list = $('instrumentList');
  list.innerHTML = '';
  if(!s.elements.length) return;

  s.elements.sort((a,b) => b.energy - a.energy);
  $('elCount').textContent = s.elements.length;

  s.elements.forEach(el => {
    const div = document.createElement('div');
    div.className = 'instrument-item' + (s.hiddenIds.has(el.id) ? ' hidden-el' : '');

    const volPct = Math.round((el.normalizedVol||0)*100);
    const panLbl = el.pan<-0.1 ? `L${Math.round(Math.abs(el.pan)*100)}` : el.pan>0.1 ? `R${Math.round(el.pan*100)}` : 'C';
    const barColor = volPct>80?'var(--red)':volPct>50?'var(--yellow)':'var(--green)';
    const confClass = el.confidence>0.6?'confidence-high':el.confidence>0.3?'confidence-mid':'confidence-low';
    const confLabel = el.confidence>0.6?'Fort':el.confidence>0.3?'Moy':'Faible';

    div.innerHTML = `
      <span class="eye-toggle" data-id="${el.id}">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          ${s.hiddenIds.has(el.id)
            ? '<line x1="1" y1="1" x2="23" y2="23"/><path d="M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94"/>'
            : '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/>'}
        </svg>
      </span>
      <span class="color-swatch" style="background:${el.color}" data-id="${el.id}"></span>
      <input type="color" class="color-input" data-id="${el.id}" value="${el.color}">
      <span class="instrument-name">${el.name}</span>
      <span class="confidence-badge ${confClass}">${confLabel}</span>
      <span class="vol-bar-wrap"><span class="vol-bar" style="width:${volPct}%;background:${barColor}"></span></span>
      <span class="instrument-db">${el.dbDisplay}dB</span>
      <span class="instrument-pan-badge">${panLbl}</span>
    `;
    list.appendChild(div);
  });

  // Eye toggle
  list.querySelectorAll('.eye-toggle').forEach(btn => {
    btn.addEventListener('click', e => {
      e.stopPropagation();
      const id = btn.dataset.id;
      if(s.hiddenIds.has(id)) s.hiddenIds.delete(id); else s.hiddenIds.add(id);
      updateInstrumentList();
      updateVisibility(activeSlot);
    });
  });

  // Color picker
  list.querySelectorAll('.color-swatch').forEach(sw => {
    sw.addEventListener('click', e => {
      e.stopPropagation();
      sw.nextElementSibling.click();
    });
  });
  list.querySelectorAll('.color-input').forEach(inp => {
    inp.addEventListener('input', e => {
      const id = inp.dataset.id;
      customColors[id] = inp.value;
      saveColors();
      const el = s.elements.find(x=>x.id===id);
      if(el) el.color = inp.value;
      updateInstrumentList();
      buildMeshes(activeSlot);
    });
  });
}

function updateVisibility(slot) {
  const s = slots[slot];
  s.groups.forEach(g => { g.group.visible = !s.hiddenIds.has(g.elId); });
}

// ======== THREE.JS SCENE ========
function initScene(slot) {
  const s = slots[slot];
  if(s.renderer) {
    s.groups.forEach(g => s.scene.remove(g.group));
    s.groups = [];
    return;
  }

  const wrap = $('canvasWrap'+slot);
  const canvas = $('scene'+slot);
  const w = wrap.clientWidth;
  const h = wrap.clientHeight;

  s.scene = new THREE.Scene();
  s.scene.fog = new THREE.FogExp2(0x08080d, 0.012);

  s.camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 300);
  updateCam(slot);

  s.renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  s.renderer.setSize(w, h);
  s.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  s.renderer.setClearColor(0x08080d);
  s.renderer.toneMapping = THREE.ACESFilmicToneMapping;
  s.renderer.toneMappingExposure = 1.2;

  // Lights
  s.scene.add(new THREE.AmbientLight(0x505070, 0.6));
  const dl = new THREE.DirectionalLight(0xffffff, 0.8);
  dl.position.set(5,12,8);
  s.scene.add(dl);
  const pl1 = new THREE.PointLight(0x00d9ce, 0.4, 40);
  pl1.position.set(-8,6,3);
  s.scene.add(pl1);
  const pl2 = new THREE.PointLight(0xe91e8c, 0.3, 40);
  pl2.position.set(8,3,-3);
  s.scene.add(pl2);

  buildStage(s.scene);
  setupCamControls(slot);
  window.addEventListener('resize', () => onResize(slot));
}

function buildStage(sc) {
  // Floor
  const fg = new THREE.PlaneGeometry(SW*2+4, SD+4);
  const fm = new THREE.MeshPhysicalMaterial({ color:0x08080e, metalness:0.85, roughness:0.2, transparent:true, opacity:0.4 });
  const fl = new THREE.Mesh(fg, fm); fl.rotation.x=-Math.PI/2; fl.position.y=-0.02;
  sc.add(fl);

  // Border
  const eg = new THREE.EdgesGeometry(new THREE.PlaneGeometry(SW*2+2, SD+2));
  const em = new THREE.LineBasicMaterial({ color:0x00d9ce, transparent:true, opacity:0.1 });
  const el = new THREE.LineSegments(eg, em); el.rotation.x=-Math.PI/2;
  sc.add(el);

  const gm = new THREE.LineBasicMaterial({ color:0x181825, transparent:true, opacity:0.5 });

  // Back wall freq zones
  FREQ_ZONES.forEach(z => {
    const y0=z.y0*SH, y1=z.y1*SH;
    const pg = new THREE.PlaneGeometry(SW*2+2, y1-y0);
    const pm = new THREE.MeshBasicMaterial({ color:new THREE.Color(z.color), transparent:true, opacity:0.04, side:THREE.DoubleSide });
    const p = new THREE.Mesh(pg, pm); p.position.set(0,(y0+y1)/2,-SD/2-0.5);
    sc.add(p);

    const lg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-SW-1,y1,-SD/2-0.5), new THREE.Vector3(SW+1,y1,-SD/2-0.5)]);
    sc.add(new THREE.Line(lg, new THREE.LineBasicMaterial({ color:new THREE.Color(z.color), transparent:true, opacity:0.2 })));

    addLabel(sc, z.label, -SW-2.2, (y0+y1)/2, -SD/2-0.5, z.color, 0.28);
  });

  // Center line
  const clg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,-SD/2-0.5), new THREE.Vector3(0,SH,-SD/2-0.5)]);
  sc.add(new THREE.Line(clg, new THREE.LineBasicMaterial({ color:0x00d9ce, transparent:true, opacity:0.2 })));

  // Pan guides
  for(let i=-2;i<=2;i++) {
    if(i===0) continue;
    const x=i*(SW/2);
    const lg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x,0,-SD/2-0.5), new THREE.Vector3(x,SH,-SD/2-0.5)]);
    sc.add(new THREE.Line(lg, gm));
  }

  // Floor depth lines
  for(let z=-SD/2; z<=SD/2; z+=1.5) {
    const lg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-SW-1,0,z), new THREE.Vector3(SW+1,0,z)]);
    sc.add(new THREE.Line(lg, gm));
  }

  // Labels
  addLabel(sc, 'L', -SW-0.5, -0.3, -SD/2-0.5, '#00d9ce', 0.35);
  addLabel(sc, 'C', 0, -0.3, -SD/2-0.5, '#00d9ce', 0.25);
  addLabel(sc, 'R', SW+0.5, -0.3, -SD/2-0.5, '#00d9ce', 0.35);
  addLabel(sc, 'DRY', 0, 0.05, SD/2+0.8, '#fbbf24', 0.18);
  addLabel(sc, 'WET', 0, 0.05, -SD/2+0.3, '#fbbf24', 0.18);
}

function addLabel(sc, text, x, y, z, color, scale) {
  const c = document.createElement('canvas');
  c.width=512; c.height=80;
  const cx = c.getContext('2d');
  cx.font = 'bold 44px Inter, sans-serif';
  cx.fillStyle = color;
  cx.textAlign = 'center';
  cx.textBaseline = 'middle';
  cx.fillText(text, 256, 40);
  const t = new THREE.CanvasTexture(c);
  const m = new THREE.SpriteMaterial({ map:t, transparent:true, opacity:0.85 });
  const sp = new THREE.Sprite(m);
  sp.position.set(x,y,z);
  sp.scale.set(scale*5, scale*0.9, 1);
  sc.add(sp);
  return sp;
}

// ======== ELEMENT MESHES - CLEAN STATIC SPHERES ========
function buildMeshes(slot) {
  const s = slots[slot];
  s.groups.forEach(g => s.scene.remove(g.group));
  s.groups = [];

  s.elements.forEach((el, i) => {
    const grp = new THREE.Group();

    // Size based on volume
    const minS = 0.25, maxS = 1.2;
    const size = minS + (el.normalizedVol||0.5) * (maxS - minS);

    // Position
    const x = el.pan * SW;
    const y = el.yPos * SH;
    const z = (0.5 - el.depth) * SD;

    // Simple clean sphere for all elements - no exotic shapes
    const geo = new THREE.SphereGeometry(size, 32, 32);
    const mat = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color(el.color),
      metalness: 0.05,
      roughness: 0.25,
      clearcoat: 0.6,
      clearcoatRoughness: 0.1,
      emissive: new THREE.Color(el.color),
      emissiveIntensity: 0.2,
      transparent: true,
      opacity: 0.92 - el.depth * 0.2,
    });
    const mesh = new THREE.Mesh(geo, mat);
    grp.add(mesh);

    // Subtle glow ring at base
    const ringGeo = new THREE.RingGeometry(size * 0.4, size * 0.7, 32);
    const ringMat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(el.color), transparent: true, opacity: 0.08, side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = -Math.PI / 2;
    ring.position.y = -y + 0.01;
    grp.add(ring);

    // Label above - large and clear
    const lbl = addLabel(s.scene, el.name, 0, size + 0.35, 0, el.color, 0.28);
    s.scene.remove(lbl);
    grp.add(lbl);

    // dB label below
    const dbLbl = addLabel(s.scene, el.dbDisplay + 'dB', 0, -(size + 0.25), 0, '#888', 0.16);
    s.scene.remove(dbLbl);
    grp.add(dbLbl);

    // Vertical stem to floor
    const stGeo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, -y, 0),
      new THREE.Vector3(0, 0, 0)
    ]);
    const stMat = new THREE.LineDashedMaterial({
      color: new THREE.Color(el.color), transparent: true, opacity: 0.1,
      dashSize: 0.2, gapSize: 0.15
    });
    const stem = new THREE.Line(stGeo, stMat);
    stem.computeLineDistances();
    grp.add(stem);

    grp.position.set(x, y, z);
    s.scene.add(grp);

    s.groups.push({ group: grp, mesh, elId: el.id, element: el, baseY: y, baseSize: size });
  });

  updateVisibility(slot);
}

// ======== CAMERA ========
function updateCam(slot) {
  const s = slots[slot];
  if(!s.camera) return;
  const x = s.camDist * Math.sin(s.camTheta) * Math.cos(s.camPhi);
  const y = s.camDist * Math.sin(s.camPhi);
  const z = s.camDist * Math.cos(s.camTheta) * Math.cos(s.camPhi);
  s.camera.position.set(s.camTarget.x + x, s.camTarget.y + y, s.camTarget.z + z);
  s.camera.lookAt(s.camTarget);
}

function syncSliders(slot) {
  if(slot !== 0) return;
  $('sliderZoom').value = Math.round(slots[0].camDist);
  $('sliderElevation').value = Math.round(slots[0].camPhi * 180 / Math.PI);
  $('sliderAngle').value = Math.round(slots[0].camTheta * 180 / Math.PI);
}

function setupCamControls(slot) {
  const canvas = $('scene' + slot);
  const s = slots[slot];

  canvas.addEventListener('mousedown', e => {
    if(e.button === 0) { s.dragging = true; s.lastX = e.clientX; s.lastY = e.clientY; }
    if(e.button === 2) { s.panning = true; s.lastX = e.clientX; s.lastY = e.clientY; }
  });
  window.addEventListener('mousemove', e => {
    if(s.dragging) {
      s.camTheta -= (e.clientX - s.lastX) * 0.005;
      s.camPhi = Math.max(-0.2, Math.min(Math.PI/2 - 0.05, s.camPhi + (e.clientY - s.lastY) * 0.005));
      s.lastX = e.clientX; s.lastY = e.clientY;
      syncSliders(slot);
    }
    if(s.panning) {
      const dx = e.clientX - s.lastX, dy = e.clientY - s.lastY;
      const right = new THREE.Vector3();
      s.camera.getWorldDirection(right);
      right.cross(new THREE.Vector3(0, 1, 0)).normalize();
      const ps = s.camDist * 0.0015;
      s.camTarget.add(right.multiplyScalar(-dx * ps));
      s.camTarget.y += dy * ps;
      s.lastX = e.clientX; s.lastY = e.clientY;
    }
  });
  window.addEventListener('mouseup', e => {
    if(e.button === 0) s.dragging = false;
    if(e.button === 2) s.panning = false;
  });
  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    s.camDist *= e.deltaY > 0 ? 1.08 : 0.92;
    s.camDist = Math.max(4, Math.min(40, s.camDist));
    syncSliders(slot);
  }, {passive: false});
  canvas.addEventListener('dblclick', () => {
    s.camDist = 14; s.camTheta = 0; s.camPhi = 25 * Math.PI / 180;
    s.camTarget.set(0, 2.5, 0);
    syncSliders(slot);
  });

  // Tooltip hover
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    $('tooltip').style.left = (e.clientX + 16) + 'px';
    $('tooltip').style.top = (e.clientY - 16) + 'px';
  });
  canvas.addEventListener('mouseleave', () => { mouse.set(-999, -999); hideTooltip(); });
}

// ======== RENDER LOOP - NO ANIMATION, STATIC OBJECTS ========
function startRenderLoop(slot) {
  const s = slots[slot];
  if(s.animId) cancelAnimationFrame(s.animId);

  function render() {
    s.animId = requestAnimationFrame(render);
    updateCam(slot);

    // Raycasting for tooltip
    const meshes = s.groups.filter(g => g.group.visible).map(g => g.mesh);
    raycaster.setFromCamera(mouse, s.camera);
    const hits = raycaster.intersectObjects(meshes);

    if(s.hovered && (!hits[0] || hits[0].object !== s.hovered)) {
      const hg = s.groups.find(g => g.mesh === s.hovered);
      if(hg) hg.mesh.material.emissiveIntensity = 0.2;
      s.hovered = null;
      hideTooltip();
    }
    if(hits.length > 0 && hits[0].object !== s.hovered) {
      s.hovered = hits[0].object;
      const hg = s.groups.find(g => g.mesh === s.hovered);
      if(hg) { hg.mesh.material.emissiveIntensity = 0.6; showTooltip(hg); }
    }

    // Playback progress
    if(s.isPlaying && s.audioBuffer) {
      const elapsed = s.audioCtx.currentTime - s.playStart + s.playOff;
      const pct = Math.min(100, elapsed / s.audioBuffer.duration * 100);
      $('progressBar' + slot).style.width = pct + '%';
      if(elapsed >= s.audioBuffer.duration) stopPlay(slot);
    }

    // Live mode: scale objects by real-time energy
    if(s.liveMode && s.isPlaying && s.analyserL) {
      updateLiveScales(s);
    }

    s.renderer.render(s.scene, s.camera);
  }
  render();
}

function updateLiveScales(s) {
  const bLen = s.analyserL.frequencyBinCount;
  const dL = new Float32Array(bLen);
  const dR = new Float32Array(bLen);
  s.analyserL.getFloatFrequencyData(dL);
  s.analyserR.getFloatFrequencyData(dR);
  const sr = s.audioCtx.sampleRate;
  const fft = s.analyserL.fftSize;

  s.groups.forEach(g => {
    if(!g.group.visible) return;
    const el = g.element;
    const lo = Math.max(0, Math.floor(el.freqRange[0] * fft / sr));
    const hi = Math.min(bLen - 1, Math.floor(el.freqRange[1] * fft / sr));
    let sL = 0, sR = 0, c = 0;
    for(let b = lo; b <= hi; b++) {
      sL += Math.pow(10, dL[b] / 20);
      sR += Math.pow(10, dR[b] / 20);
      c++;
    }
    if(c > 0) { sL /= c; sR /= c; }
    const e = (sL + sR) / 2;
    const sc = Math.min(2.5, Math.max(0.3, e * 6));
    g.mesh.scale.lerp(new THREE.Vector3(sc, sc, sc), 0.15);
  });
}

// ======== TOOLTIP ========
function showTooltip(g) {
  const el = g.element;
  const tt = $('tooltip');
  tt.style.display = 'block';
  tt.querySelector('.tt-name').textContent = el.name;
  tt.querySelector('.tt-name').style.color = el.color;
  $('ttVol').textContent = Math.round((el.normalizedVol || 0) * 100) + '% (' + el.dbDisplay + 'dB)';
  $('ttVolBar').style.width = Math.round((el.normalizedVol || 0) * 100) + '%';
  $('ttVolBar').style.background = el.color;
  $('ttPan').textContent = el.pan < -0.1 ? `Gauche ${Math.round(Math.abs(el.pan)*100)}%` : el.pan > 0.1 ? `Droite ${Math.round(el.pan*100)}%` : 'Centre';
  const fmt = f => f >= 1000 ? (f/1000).toFixed(1) + 'k' : f + '';
  $('ttFreq').textContent = fmt(el.freqRange[0]) + ' - ' + fmt(el.freqRange[1]) + ' Hz';
  const dp = Math.round(el.depth * 100);
  $('ttDepth').textContent = dp < 25 ? `Devant (${dp}%)` : dp > 60 ? `Arriere (${dp}%)` : `Milieu (${dp}%)`;
  $('ttConf').textContent = Math.round(el.confidence * 100) + '%';
}
function hideTooltip() { $('tooltip').style.display = 'none'; }

// ======== PLAYBACK ========
document.querySelectorAll('.btnPlay').forEach(b => b.addEventListener('click', () => startPlay(+b.dataset.slot)));
document.querySelectorAll('.btnPause').forEach(b => b.addEventListener('click', () => stopPlay(+b.dataset.slot)));
document.querySelectorAll('.btnLive').forEach(b => b.addEventListener('click', () => {
  const s = slots[+b.dataset.slot];
  s.liveMode = !s.liveMode;
  b.classList.toggle('active', s.liveMode);
}));

function startPlay(slot) {
  const s = slots[slot];
  if(!s.audioBuffer || s.isPlaying) return;
  s.audioCtx.resume();
  s.source = s.audioCtx.createBufferSource();
  s.source.buffer = s.audioBuffer;
  s.splitter = s.audioCtx.createChannelSplitter(2);
  s.analyserL = s.audioCtx.createAnalyser();
  s.analyserR = s.audioCtx.createAnalyser();
  s.analyserL.fftSize = 2048;
  s.analyserR.fftSize = 2048;
  s.source.connect(s.splitter);
  s.source.connect(s.audioCtx.destination);
  s.splitter.connect(s.analyserL, 0);
  s.splitter.connect(s.analyserR, 1);
  s.playStart = s.audioCtx.currentTime;
  s.source.start(0, s.playOff);
  s.isPlaying = true;
  s.source.onended = () => {
    if(s.isPlaying) { s.isPlaying = false; s.playOff = 0; $('progressBar' + slot).style.width = '0%'; }
  };
}

function stopPlay(slot) {
  const s = slots[slot];
  if(!s.isPlaying) return;
  s.playOff = s.audioCtx.currentTime - s.playStart + s.playOff;
  if(s.source) { s.source.onended = null; s.source.stop(); }
  s.isPlaying = false;
}

// ======== RESIZE ========
function onResize(slot) {
  const s = slots[slot];
  if(!s.renderer) return;
  const w = $('canvasWrap' + slot).clientWidth;
  const h = $('canvasWrap' + slot).clientHeight;
  s.camera.aspect = w / h;
  s.camera.updateProjectionMatrix();
  s.renderer.setSize(w, h);
}

// ======== COMPARE MODE ========
$('btnCompare').addEventListener('click', () => {
  compareMode = !compareMode;
  $('btnCompare').classList.toggle('active', compareMode);
  $('app').classList.toggle('compare-mode', compareMode);
  $('canvasWrap1').style.display = compareMode ? 'block' : 'none';
  $('uploadTabs').style.display = compareMode ? 'flex' : 'none';
  $('dropzone1').style.display = compareMode ? 'block' : 'none';
  setTimeout(() => { onResize(0); if(compareMode && slots[1].renderer) onResize(1); }, 100);
});

// Upload tabs
document.querySelectorAll('.upload-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    activeSlot = +tab.dataset.slot;
    document.querySelectorAll('.upload-tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    updateInstrumentList();
  });
});

// ======== SLIDERS ========
$('sliderZoom').addEventListener('input', e => { slots[0].camDist = parseFloat(e.target.value); });
$('sliderElevation').addEventListener('input', e => { slots[0].camPhi = parseFloat(e.target.value) * Math.PI / 180; });
$('sliderAngle').addEventListener('input', e => { slots[0].camTheta = parseFloat(e.target.value) * Math.PI / 180; });
$('sliderThreshold').addEventListener('input', e => {
  sensitivitySetting = parseInt(e.target.value);
  [0,1].forEach(sl => { if(slots[sl].audioBuffer) { analyzeAudioAdvanced(sl); buildMeshes(sl); } });
  updateInstrumentList();
});

// ======== SHOW ALL / RESET ========
$('btnShowAll').addEventListener('click', () => {
  slots[activeSlot].hiddenIds.clear();
  updateInstrumentList();
  updateVisibility(activeSlot);
});

$('btnReset').addEventListener('click', () => {
  [0,1].forEach(sl => {
    const s = slots[sl];
    if(s.isPlaying) stopPlay(sl);
    s.audioBuffer = null; s.source = null; s.elements = []; s.hiddenIds.clear(); s.playOff = 0;
    if(s.renderer) {
      while(s.scene.children.length > 0) s.scene.remove(s.scene.children[0]);
      s.groups = []; s.renderer.dispose(); s.renderer = null;
    }
    $('emptyState' + sl).style.display = 'flex';
    $('transport' + sl).style.display = 'none';
    $('fileName' + sl).textContent = '';
    $('progressBar' + sl).style.width = '0%';
    const c = $('scene' + sl); c.width = 0; c.height = 0;
  });
  $('panelInstruments').style.display = 'none';
  $('instrumentList').innerHTML = '';
  $('hud0').style.display = 'none';
  $('controlsHelp0').style.display = 'none';
});

})();
</script>
</body>
</html>
